/*************************/
/ Predicates Declarations /
/*************************/
primitive(vulExists(_Host, _VulID, _Software, _ExploitRange, _ExploitConsequence)).
primitive(vulExists(_Host, _VulID, _Software)).
primitive(vulProperty(_VulID, _ExploitRange, _ExploitConsequence)).
primitive(bugHyp(_Host, _Software, _ExploitRange, _ExploitConsequence)).
primitive(dependsOn(_Host, _Software, _Library)).
primitive(networkService(_Host, _Software, _Protocol, _Port, _Account)).
primitive(setuidProgram(_Host, _Software, _Account)).
primitive(clientProgram(_Host, _Software)).
primitive(malicious(_User)).
primitive(incompetent(_User)).
primitive(fileAttr(_Host, _Path, _R1, _W1, _X1, _R2, _W2, _X2, _R3, _W3, _X3)).
primitive(nfsExportInfo(_ServerHost, _Path, _ClientHost, _Permission, _RootSquash, _IsSecure)).
primitive(nfsUserMap(_Account, _Account, _no_root_squash)).
primitive(non_root_user(_User)).
primitive(nfsMounted(_ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission)).
primitive(hacl(_SrcHost, _DstHost, _Protocol, _DestPort)).
primitive(allow(_User, _Permission, _Data)).
primitive(hasAccount(_User, _Host, _Account)).
primitive(located(_User, _Zone)).
primitive(dataBind(_Data, _Host, _Path)).
primitive(dataBindDir(_Data, _Host, _DirPath)).
primitive(isAdmin(_User, _Host)).
primitive(gateway(_Host)).
primitive(flowExists(_SrcHost, _DstHost, _Protocol, _Port, _Account)).
primitive(isInstance(_Vm_id, _VMI_id)).
primitive(imageVulExists(_VMI_id, _VulID, _Software, _ExploitRange, _ExploitConsequence)).
primitive(isThirdPartyImage(_VMI_id)).
primitive(resideOn(_VM_id, _H_id)).
primitive(misuseAction(_Action)).
primitive(modifyInfoAct(_Action, _Resource)).
primitive(canLeadToPrivEscalation(_Action)).
primitive(attackerLocated(_Host)).
primitive(canAccessFile(_Host, _Account, _Path)).
primitive(installed(_Host, _Software)).
primitive(sendsFile(_HostTX, _HostRX, _FileName, _Software)).
primitive(listenForFiles(_Host, _Software)).
primitive(hostProvideService(_Host, _Service)).
primitive(networkHardware(_Host)).
primitive(instantiate(_Host, _VM)).
primitive(own(_Tenant, _Element)).
primitive(isAttachedTo(_VirtualPort, _Element)).
primitive(belongTo(_Subnet, _VirtualPort)).
primitive(isLinkedTo(_Subnet, _Network)).
primitive(contains(_SecurityGroup, _SecurityRule)).
primitive(isEnforcedOn(_SecurityGroup, _VM)).
primitive(hasIP(_IP, _Host)).
primitive(fileAcl(_FileName, _Owner, _Dacl)).
primitive(owner(_Sid)).
primitive(dacl(_acl([AceHeadEntry | ACLTail]))).
primitive(processToken(_UserSid, _Permission, _Groups, _RestrictedGroups)).
primitive(N(_N)).
primitive(userToken(_Principal, _Token)).
primitive(trusts(_Host, _Resource)).
primitive(trusts(_Host, _resource(service, _Name, _Dacl))).
derived(vulExists(_Host, _VulID, _Software, _Range, _Consequence)).
derived(vulProperty(_VulID, _ExploitRange, _ExploitConsequence)).
derived(dependsOn(_Host, _DependedSoftware1, _DependedSoftware3)).
derived(execCode(_User, _Host, _Account)).
derived(accessFile(_User, _Host, _Permission, _Path)).
derived(localFileProtection(_Host, _Account, _Permission, _Path)).
derived(ownerAccessible(_Host, _read, _Path)).
derived(groupAccessible(_Host, _read, _Path)).
derived(worldAccessible(_Host, _read, _Path)).
derived(nfsUserMap(_Account, _Account, _root_squash)).
derived(nfsMounted(_ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission)).
derived(principalCompromised(_Victim, _Attacker)).
derived(canAccessHost(_User, _Host)).
derived(logInService(_Host, _Protocol, _Port)).
derived(netAccess(_User, _SrcHost, _DstHost, _Protocol, _Port)).
derived(hasAccount(_User, _Host2, _Account)).
derived(spoofLinkHost(_User, _ImpersonatedHost, _FooledHost, _AttackerHost, _trafficTheft)).
derived(spoofE2EHost(_User, _ImpersonatedHost, _FooledHost, _AttackerHost1, _Prot, _Port, _trafficTheft)).
derived(dos(_User, _Host)).
derived(mitmLink(_User, _SrcHost, _DstHost, _SpoofingHost)).
derived(relay(_MITMHost, _FlowName)).
derived(mitmE2E(_User, _SrcHost, _DstHost, _SpoofingHost, _Prot, _Port)).
derived(relay(_MITMHost, _SrcHost, _DstHost, _Prot, _Port)).
derived(crackAPEncKey(_User, _Host, _AP)).
derived(accessDataFlow(_User, _FlowName, _read)).
derived(isAuthenticated(_User, _AttackerHost, _AP)).
derived(accessLinkFlow(_User, _Host, _AP, _Protocol, _read)).
derived(crackPINCode(_User, _SrcHost, _DstHost, _BluetoothProt)).
derived(localAccess(_attacker, _Host, _admin)).
derived(l2Access(_User, _SrcHost, _DstHost, _Prot, _Zone, _Type)).
derived(l2Connection(_SrcHost, _DstHost, _BusID, _Prot, _bus)).
derived(vulHost(_Host, _ID, _Software, _Range, _Consequense)).
derived(vulLinkProtocol(_HostA, _HostB, _VulID, _Protocol, _Range, _Consequence)).
derived(aclNW(_SrcHost, _DstHost, _Prot, _Port)).
derived(dataInject(_User, _Host, _Software, _Account)).
derived(located(_SrcHost, _DstZone, _Type)).
derived(dataFlow(_SrcHost, _Flowname)).
derived(dataFlow(_SrcHost, _DstHost, _Flowname)).
derived(dataInject(_User, _DstHost, _Path2)).
derived(accessMaliciousInput(_Host, _Victim, _Software)).
derived(hostImpact(_VM)).
derived(serviceImpacted(_Service, _Host, _Account)).
derived(imageVulExists(_VMI_id, _stealthyBridge_id, _Software, _remoteExploit, _privEscalation)).
derived(stealthyBridgeExists(_Vm_1, _Vm_2, _Host, _stealthyBridge_id)).
derived(leakInfo(_Host)).
derived(leakInfo(_Host, _code)).
derived(tamperInfo(_Host, _Resource)).
derived(execCode(_Host, _root)).
derived(execArbitraryCode(_Host, _Account)).
derived(systemDown(_Host)).
derived(firstHop(_Host1, _Host2)).
derived(sameSwitch(_Host1, _Host2)).
derived(multiHop(_SrcHost, _TgtHost)).
derived(pivotPoint(_SrcHost, _TgtHost)).
derived(canReceiveFile(_HostRX, _HostTX, _FileName)).
derived(canSendFile(_SrcHost, _TgtHost, _Software)).
derived(canDoS(_SrcHost, _TgtHost, _Software)).
derived(dataTransitsThrough(_Host, _FileName)).
derived(manInTheMiddle(_Host, _TxHost, _RxHost)).
derived(vulnerableToMakingDefectiveParts(_TgtHost, _AtkHost)).
derived(vulnerableToDataExfiltration(_TgtHost, _SrcHost)).
derived(vulnerableToDoS(_TgtHost, _SrcHost)).
derived(areColocated(_Vm1, _Vm2)).
derived(isInSubnet(_Subnet, _Vm)).
derived(areRouted(_Router, _Subnet1, _Subnet2)).
derived(areConnected(_Vm1, _Vm2)).
derived(mulvalCheckAccess(_allowed, _fileACL(_FileName, _Owner, _dacl(null)), _RequestedAccess, _Software)).
derived(checkAccess(_allowed, _FileDacl, _RequestedAccess, _Software)).
derived(canAccess (_User, _Permission, _Resource)).
derived(principalCompromised (_User)).
derived(windowsAccessCheck(_denied, _SecurityDescriptor, _RequestedAccess, _ProcessToken)).
derived(canWrite(_User, _resource(Type, _Name, _Dacl))).
derived(accessData(_User, _Permission, _Data)).
derived(policyViolation(_User, _Permission, _Data)).
derived(netAccess(_Host2, _Protocol, _Port)).
derived(softwareCompromised(_Software)).
derived(exCompromised(_ExternalSoftware)).
derived(canInjectCommand(_ExternalSoftware)).
derived(canPrivEsc(_Software)).
derived(canDeleteDoc(_Software)).
derived(evasionAttack(_User, _PiplineID, _ModelID, _tampering)).
derived(mlModelCorruptionAttack(_User, _PiplineID, _ModelID, _tampering_dos)).
derived(membershipInferenceAttack(_User, _PiplineID, _ModelID, _informationDisclosure)).
derived(dataPropertyInferenceAttack(_User, _PiplineID, _ModelID, _informationDisclosure)).
derived(dataReconstructionAttack(_User, _PiplineID, _ModelID, _informationDisclosure)).
derived(modelExtractionAttack(_User, _PiplineID, _ModelID, _informationDisclosure)).
derived(labelManipulationAttack(_User, _PiplineID, _ModelID)).
derived(manipulateTrainingData(_User, _PiplineID, _ModelID)).
derived(dataTransformationJob(_JobID, _WorkerHost, _InputDataID, _WorkerHost, _TransformedDataID, _TransformedDataHost)).
derived(modelAcces5(_User, _PiplineID, _ModelID, _read, _AccessLevel)).
derived(modelAccess(_User, _PiplineID, _ModelID, _write, _AccessLevel)).
derived(trainingDataAccess(_User, _PiplineID, _ModelID, _TrainingDataID, _read, _AccessLevel)).
derived(queryAccess(_User, _PiplineID, _ModelID, _PredictionsGranularity, _AccessLevel)).
derived(completeAccess(_User, _PiplineID, _ModelID, _DataAccessPrivilege)).
derived(modelKnowledge(_User, _PiplineID, _ModelID, _KnowledgeLevel)).
derived(hyperparametersKnowledge(_User, _PiplineID, _ModelID, _KnowledgeLevel)).
derived(algorithmKnowledge(_User, _PiplineID, _ModelID, _KnowledgeLevel)).
derived(trainingDataKnowledge(_User, _PiplineID, _ModelID, _TrainingDataID, _KnowledgeLevel)).
derived(completeKnowledge(_User, _PiplineID, _ModelID)).
derived(createSurrogateModel(_User, _PiplineID, _ModelID)).

meta(attackGoal(_)).

/*******************************************/
/****      Tabling Predicates          *****/
/* All derived predicates should be tabled */
/*******************************************/
:- table vulExists/5.
:- table vulProperty/3.
:- table dependsOn/3.
:- table execCode/3.
:- table accessFile/4.
:- table localFileProtection/4.
:- table ownerAccessible/3.
:- table groupAccessible/3.
:- table worldAccessible/3.
:- table nfsUserMap/3.
:- table nfsMounted/5.
:- table principalCompromised/2.
:- table canAccessHost/2.
:- table logInService/3.
:- table netAccess/5.
:- table hasAccount/3.
:- table spoofLinkHost/5.
:- table spoofE2EHost/7.
:- table dos/2.
:- table mitmLink/4.
:- table relay/2.
:- table mitmE2E/6.
:- table relay/5.
:- table crackAPEncKey/3.
:- table accessDataFlow/3.
:- table isAuthenticated/3.
:- table accessLinkFlow/5.
:- table crackPINCode/4.
:- table localAccess/3.
:- table l2Access/6.
:- table l2Connection/5.
:- table vulHost/5.
:- table vulLinkProtocol/6.
:- table aclNW/4.
:- table dataInject/4.
:- table located/3.
:- table dataFlow/2.
:- table dataFlow/3.
:- table dataInject/3.
:- table accessMaliciousInput/3.
:- table hostImpact/1.
:- table serviceImpacted/3.
:- table imageVulExists/5.
:- table stealthyBridgeExists/4.
:- table leakInfo/1.
:- table leakInfo/2.
:- table tamperInfo/2.
:- table execCode/2.
:- table execArbitraryCode/2.
:- table systemDown/1.
:- table firstHop/2.
:- table sameSwitch/2.
:- table multiHop/2.
:- table pivotPoint/2.
:- table canReceiveFile/3.
:- table canSendFile/3.
:- table canDoS/3.
:- table dataTransitsThrough/2.
:- table manInTheMiddle/3.
:- table vulnerableToMakingDefectiveParts/2.
:- table vulnerableToDataExfiltration/2.
:- table vulnerableToDoS/2.
:- table areColocated/2.
:- table isInSubnet/2.
:- table areRouted/3.
:- table areConnected/2.
:- table mulvalCheckAccess/6.
:- table checkAccess/4.
:- table canAccess /3.
:- table principalCompromised /1.
:- table windowsAccessCheck/4.
:- table canWrite/4.
:- table accessData/3.
:- table policyViolation/3.
:- table netAccess/3.
:- table softwareCompromised/1.
:- table exCompromised/1.
:- table canInjectCommand/1.
:- table canPrivEsc/1.
:- table canDeleteDoc/1.
:- table evasionAttack/4.
:- table mlModelCorruptionAttack/4.
:- table membershipInferenceAttack/4.
:- table dataPropertyInferenceAttack/4.
:- table dataReconstructionAttack/4.
:- table modelExtractionAttack/4.
:- table labelManipulationAttack/3.
:- table manipulateTrainingData/3.
:- table dataTransformationJob/6.
:- table modelAcces5/5.
:- table modelAccess/5.
:- table trainingDataAccess/6.
:- table queryAccess/5.
:- table completeAccess/4.
:- table modelKnowledge/4.
:- table hyperparametersKnowledge/4.
:- table algorithmKnowledge/4.
:- table trainingDataKnowledge/5.
:- table completeKnowledge/3.
:- table createSurrogateModel/3.

/*******************/
/ Interaction Rules /
/*******************/
interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, VulID, Software),
  vulProperty(VulID, Range, Consequence)),
 rule_desc('A vulnerability exists in the Program on a Host, and it has specific ExploitRange and ExploitConsequence.
Program is the full path of the executable that contains the security bug.', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, ExploitRange, ExploitConsequence):-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('Hypothetical Bug', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, _VulID, DependedSoftware, Range, Consequence),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('Library Bug', 1.0)).

interaction_rule(
 (vulExists(Vm_id, vulID, _Software, _Range, _Consequence) :-
  imageVulExists(VMI_id, vulID, _Software, _Range, _Consequence),
  isInstance(Vm_id, VMI_id)),
 rule_desc('A virtual machine instance inherits the vulnerability from the parent VMI.', 1.0)).

interaction_rule(
 (vulExists(Host, VulID, Sw, ExploitRange, ExploitConsequence) :-
  vulExists(Host, VulID, Sw),
  vulProperty(VulID, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, VulID, Software),
  vulProperty(VulID, Range, Consequence)),
 rule_desc('A vulnerability exists in the Program on a Host, and it has specific ExploitRange and ExploitConsequence.
Program is the full path of the executable that contains the security bug.', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, ExploitRange, ExploitConsequence):-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('Hypothetical Bug', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, _VulID, DependedSoftware, Range, Consequence),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('Library Bug', 1.0)).

interaction_rule(
 (vulExists(Vm_id, vulID, _Software, _Range, _Consequence) :-
  imageVulExists(VMI_id, vulID, _Software, _Range, _Consequence),
  isInstance(Vm_id, VMI_id)),
 rule_desc('A virtual machine instance inherits the vulnerability from the parent VMI.', 1.0)).

interaction_rule(
 (vulExists(Host, VulID, Sw, ExploitRange, ExploitConsequence) :-
  vulExists(Host, VulID, Sw),
  vulProperty(VulID, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, VulID, Software),
  vulProperty(VulID, Range, Consequence)),
 rule_desc('A vulnerability exists in the Program on a Host, and it has specific ExploitRange and ExploitConsequence.
Program is the full path of the executable that contains the security bug.', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, ExploitRange, ExploitConsequence):-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('Hypothetical Bug', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, _VulID, DependedSoftware, Range, Consequence),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('Library Bug', 1.0)).

interaction_rule(
 (vulExists(Vm_id, vulID, _Software, _Range, _Consequence) :-
  imageVulExists(VMI_id, vulID, _Software, _Range, _Consequence),
  isInstance(Vm_id, VMI_id)),
 rule_desc('A virtual machine instance inherits the vulnerability from the parent VMI.', 1.0)).

interaction_rule(
 (vulExists(Host, VulID, Sw, ExploitRange, ExploitConsequence) :-
  vulExists(Host, VulID, Sw),
  vulProperty(VulID, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulProperty(VulID, ExploitRange, ExploitConsequence) :-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (dependsOn(Host, DependedSoftware1, DependedSoftware3) :-
  dependsOn(Host, DependedSoftware1, DependedSoftware2),
  dependsOn(Host, DependedSoftware2, DependedSoftware3)),
 rule_desc('Transitive dependencies', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, read, Path) :-
  fileAttr(Host, Path, r,_,_,_,_,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by its owner', 1.0)).

interaction_rule(
 (ownerAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,w,_,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,x,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, read, Path) :-
  fileAttr(Host, Path, r,_,_,_,_,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by its owner', 1.0)).

interaction_rule(
 (ownerAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,w,_,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,x,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, read, Path) :-
  fileAttr(Host, Path, r,_,_,_,_,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by its owner', 1.0)).

interaction_rule(
 (ownerAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,w,_,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,x,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,r,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by group', 1.0)).

interaction_rule(
 (groupAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,w,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,x,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,r,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by group', 1.0)).

interaction_rule(
 (groupAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,w,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,x,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,r,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by group', 1.0)).

interaction_rule(
 (groupAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,w,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,x,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,r,_,_)),
 rule_desc('The file Path on Machine Host has Access by anyone', 1.0)).

interaction_rule(
 (worldAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,w,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,_,x)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,r,_,_)),
 rule_desc('The file Path on Machine Host has Access by anyone', 1.0)).

interaction_rule(
 (worldAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,w,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,_,x)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,r,_,_)),
 rule_desc('The file Path on Machine Host has Access by anyone', 1.0)).

interaction_rule(
 (worldAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,w,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,_,x)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (logInService(Host, Protocol, Port) :-
  networkService(Host, sshd, Protocol, Port, _Account)),
 rule_desc('ssh is a log in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, trafficTheft):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Access(User, AttackerHost, ImpersonatedHost, Prot, Zone, ipSubnet)),
 rule_desc('ARP Spoofing: an attacker can route the traffic intended for some host to the attackers machine.
Spoofing the source host in link layer and the impersonated and fooled hosts reside in the same subnet.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, trafficTheft):-
  vulLinkProtocol(RelayHost, ImpersonatedHost, VulID, Prot, adjacent, impersonateDst),
  l2Access(User, AttackerHost, ImpersonatedHost, Prot, Subnet, ipSubnet),
  dataFlow(FooledHost, ImpersonatedHost, FlowName, _Direction),
  isGateway(RelayHost, Subnet)),
 rule_desc('The impersonated and fooled hosts reside in different subnets.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, deception):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Connection(AttackerHost, FooledHost, BusID, Prot, bus),
  localAccess(User, AttackerHost, _Account),
  isMaster(ImpersonatedHost, BusID)),
 rule_desc('Attacks on Bus Communication; Principal impersonates as the bus master.
The master spoofing scenario: the attacker Principal can log in to the AttackerHost (represented by the localAccess) which is connected to the same bus as FooledHost (represented by the l2Connection). By exploiting a vulnerability in the communication protocol used by ImpersonatesHost and FooledHost (represented by the vulLinkProtocol), Principal is able to impersonate as ImpersonatesHost, which is the master in the bus (isMaster).', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, deception):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Connection(AttackerHost, FooledHost, BusID, Prot, bus),
  localAccess(User, AttackerHost, Account),
  isSlave(ImpersonatedHost, BusID)),
 rule_desc('Attacks on Bus Communication; Principal impersonates as a bus salve.
The slave spoofing scenario: is similar to the master spoofing scenario, except for the fact that ImpersonatesHost is a slave in the bus (represented by the isSlave) and not the master.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, trafficTheft):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Access(User, AttackerHost, ImpersonatedHost, Prot, Zone, ipSubnet)),
 rule_desc('ARP Spoofing: an attacker can route the traffic intended for some host to the attackers machine.
Spoofing the source host in link layer and the impersonated and fooled hosts reside in the same subnet.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, trafficTheft):-
  vulLinkProtocol(RelayHost, ImpersonatedHost, VulID, Prot, adjacent, impersonateDst),
  l2Access(User, AttackerHost, ImpersonatedHost, Prot, Subnet, ipSubnet),
  dataFlow(FooledHost, ImpersonatedHost, FlowName, _Direction),
  isGateway(RelayHost, Subnet)),
 rule_desc('The impersonated and fooled hosts reside in different subnets.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, deception):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Connection(AttackerHost, FooledHost, BusID, Prot, bus),
  localAccess(User, AttackerHost, _Account),
  isMaster(ImpersonatedHost, BusID)),
 rule_desc('Attacks on Bus Communication; Principal impersonates as the bus master.
The master spoofing scenario: the attacker Principal can log in to the AttackerHost (represented by the localAccess) which is connected to the same bus as FooledHost (represented by the l2Connection). By exploiting a vulnerability in the communication protocol used by ImpersonatesHost and FooledHost (represented by the vulLinkProtocol), Principal is able to impersonate as ImpersonatesHost, which is the master in the bus (isMaster).', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, deception):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Connection(AttackerHost, FooledHost, BusID, Prot, bus),
  localAccess(User, AttackerHost, Account),
  isSlave(ImpersonatedHost, BusID)),
 rule_desc('Attacks on Bus Communication; Principal impersonates as a bus salve.
The slave spoofing scenario: is similar to the master spoofing scenario, except for the fact that ImpersonatesHost is a slave in the bus (represented by the isSlave) and not the master.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, trafficTheft):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Access(User, AttackerHost, ImpersonatedHost, Prot, Zone, ipSubnet)),
 rule_desc('ARP Spoofing: an attacker can route the traffic intended for some host to the attackers machine.
Spoofing the source host in link layer and the impersonated and fooled hosts reside in the same subnet.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, trafficTheft):-
  vulLinkProtocol(RelayHost, ImpersonatedHost, VulID, Prot, adjacent, impersonateDst),
  l2Access(User, AttackerHost, ImpersonatedHost, Prot, Subnet, ipSubnet),
  dataFlow(FooledHost, ImpersonatedHost, FlowName, _Direction),
  isGateway(RelayHost, Subnet)),
 rule_desc('The impersonated and fooled hosts reside in different subnets.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, deception):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Connection(AttackerHost, FooledHost, BusID, Prot, bus),
  localAccess(User, AttackerHost, _Account),
  isMaster(ImpersonatedHost, BusID)),
 rule_desc('Attacks on Bus Communication; Principal impersonates as the bus master.
The master spoofing scenario: the attacker Principal can log in to the AttackerHost (represented by the localAccess) which is connected to the same bus as FooledHost (represented by the l2Connection). By exploiting a vulnerability in the communication protocol used by ImpersonatesHost and FooledHost (represented by the vulLinkProtocol), Principal is able to impersonate as ImpersonatesHost, which is the master in the bus (isMaster).', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, deception):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Connection(AttackerHost, FooledHost, BusID, Prot, bus),
  localAccess(User, AttackerHost, Account),
  isSlave(ImpersonatedHost, BusID)),
 rule_desc('Attacks on Bus Communication; Principal impersonates as a bus salve.
The slave spoofing scenario: is similar to the master spoofing scenario, except for the fact that ImpersonatesHost is a slave in the bus (represented by the isSlave) and not the master.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, trafficTheft):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Access(User, AttackerHost, ImpersonatedHost, Prot, Zone, ipSubnet)),
 rule_desc('ARP Spoofing: an attacker can route the traffic intended for some host to the attackers machine.
Spoofing the source host in link layer and the impersonated and fooled hosts reside in the same subnet.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, trafficTheft):-
  vulLinkProtocol(RelayHost, ImpersonatedHost, VulID, Prot, adjacent, impersonateDst),
  l2Access(User, AttackerHost, ImpersonatedHost, Prot, Subnet, ipSubnet),
  dataFlow(FooledHost, ImpersonatedHost, FlowName, _Direction),
  isGateway(RelayHost, Subnet)),
 rule_desc('The impersonated and fooled hosts reside in different subnets.', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, deception):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Connection(AttackerHost, FooledHost, BusID, Prot, bus),
  localAccess(User, AttackerHost, _Account),
  isMaster(ImpersonatedHost, BusID)),
 rule_desc('Attacks on Bus Communication; Principal impersonates as the bus master.
The master spoofing scenario: the attacker Principal can log in to the AttackerHost (represented by the localAccess) which is connected to the same bus as FooledHost (represented by the l2Connection). By exploiting a vulnerability in the communication protocol used by ImpersonatesHost and FooledHost (represented by the vulLinkProtocol), Principal is able to impersonate as ImpersonatesHost, which is the master in the bus (isMaster).', 1.0)).

interaction_rule(
 (spoofLinkHost(User, ImpersonatedHost, FooledHost, AttackerHost, deception):-
  vulLinkProtocol(ImpersonatedHost, FooledHost, _vulID, Prot, adjacent, impersonateSrc),
  l2Connection(AttackerHost, FooledHost, BusID, Prot, bus),
  localAccess(User, AttackerHost, Account),
  isSlave(ImpersonatedHost, BusID)),
 rule_desc('Attacks on Bus Communication; Principal impersonates as a bus salve.
The slave spoofing scenario: is similar to the master spoofing scenario, except for the fact that ImpersonatesHost is a slave in the bus (represented by the isSlave) and not the master.', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost1, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  vulE2EProtocol(FooledHost, NameResolver, dnsCachePoisoning, dns, DNSProt, remoteExploit, nameresolverCachePoisoned),
  netAccess(User, AttackerHost1, NameResolver, dns, DNSPort)),
 rule_desc('DNS Spoofing; NameResolver cache poisoning. The attacker spoofs as the name server and provides malicious binding for legitimate requests.
The attacker provides a fake response by utilizing a race condition (i.e., answers faster than the legitimate server).The DNS server communicates using a vulnerable version of the DNS protocol, represented by the isNameResolver and netAccess.', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  localAccess(User, NameResolver, admin),
  netAccess(User2, FooledHost, AttackerHost, Prot, Port),
  localAccess(User, AttackerHost, _Account)),
 rule_desc('The attacker changes DNS records in the name server/host cache. The attacker (Principal) can log in using local access (localAccess predicates) to the DNS server and modify the DNS records to associate the attackers host with a naming of his/hers choice. The success of the attack depends on the ability of the fooled host to access the attackers host through the network (expressed by the netAccess predicate).', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  accessFile(User, NameResolver, write, RecoredPath),
  dataBind(NameResolverRecord, NameResolver, RecoredPath),
  isNameResolverRecord(NameResolverRecord)),
 rule_desc('Gaining write access permission to some path in the DNS server, which happens to contain a DNS record.', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost1, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  vulE2EProtocol(FooledHost, NameResolver, dnsCachePoisoning, dns, DNSProt, remoteExploit, nameresolverCachePoisoned),
  netAccess(User, AttackerHost1, NameResolver, dns, DNSPort)),
 rule_desc('DNS Spoofing; NameResolver cache poisoning. The attacker spoofs as the name server and provides malicious binding for legitimate requests.
The attacker provides a fake response by utilizing a race condition (i.e., answers faster than the legitimate server).The DNS server communicates using a vulnerable version of the DNS protocol, represented by the isNameResolver and netAccess.', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  localAccess(User, NameResolver, admin),
  netAccess(User2, FooledHost, AttackerHost, Prot, Port),
  localAccess(User, AttackerHost, _Account)),
 rule_desc('The attacker changes DNS records in the name server/host cache. The attacker (Principal) can log in using local access (localAccess predicates) to the DNS server and modify the DNS records to associate the attackers host with a naming of his/hers choice. The success of the attack depends on the ability of the fooled host to access the attackers host through the network (expressed by the netAccess predicate).', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  accessFile(User, NameResolver, write, RecoredPath),
  dataBind(NameResolverRecord, NameResolver, RecoredPath),
  isNameResolverRecord(NameResolverRecord)),
 rule_desc('Gaining write access permission to some path in the DNS server, which happens to contain a DNS record.', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost1, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  vulE2EProtocol(FooledHost, NameResolver, dnsCachePoisoning, dns, DNSProt, remoteExploit, nameresolverCachePoisoned),
  netAccess(User, AttackerHost1, NameResolver, dns, DNSPort)),
 rule_desc('DNS Spoofing; NameResolver cache poisoning. The attacker spoofs as the name server and provides malicious binding for legitimate requests.
The attacker provides a fake response by utilizing a race condition (i.e., answers faster than the legitimate server).The DNS server communicates using a vulnerable version of the DNS protocol, represented by the isNameResolver and netAccess.', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  localAccess(User, NameResolver, admin),
  netAccess(User2, FooledHost, AttackerHost, Prot, Port),
  localAccess(User, AttackerHost, _Account)),
 rule_desc('The attacker changes DNS records in the name server/host cache. The attacker (Principal) can log in using local access (localAccess predicates) to the DNS server and modify the DNS records to associate the attackers host with a naming of his/hers choice. The success of the attack depends on the ability of the fooled host to access the attackers host through the network (expressed by the netAccess predicate).', 1.0)).

interaction_rule(
 (spoofE2EHost(User, ImpersonatedHost, FooledHost, AttackerHost, Prot, Port, trafficTheft):-
  isNameResolver(NameResolver, FooledHost, ImpersonatedHost),
  accessFile(User, NameResolver, write, RecoredPath),
  dataBind(NameResolverRecord, NameResolver, RecoredPath),
  isNameResolverRecord(NameResolverRecord)),
 rule_desc('Gaining write access permission to some path in the DNS server, which happens to contain a DNS record.', 1.0)).

interaction_rule(
 (dos(User, Host):-
  localAccess(User, Host, Account),
  localService(Host, Software, Account),
  vulHost(Host, VulID, Software, localExploit, dos),
  malicious(User)),
 rule_desc('Host-based DoS attacks. The attacker Principal (represented by the malicious predicate) exploits his/her login access to Host (represented by localAccess) which runs a vulnerable service that allows DoS (represented by the localService and vulHost).', 1.0)).

interaction_rule(
 (dos(User, DstHost):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, dos),
  malicious(User),
  netAccess5(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network. Network-based DoS attacks. The attacker Principal exploits his/her access to a network service running on DstHost (represented by the netAccess, aclH, and networkService), which contains a vulnerability that enables DoS upon successful exploitation (represented by the vulHost).', 1.0)).

interaction_rule(
 (dos(User, DstHost):-
  malicious(User),
  l2Access(User, SrcHost, DstHost, Prot, BusID, bus)),
 rule_desc('Attacks on Bus Communication; Malicious access to the bus.
Attacker Principal (represented by the malicious predicate) can utilize his/her local access (i.e., login or ability to execute code) to a device connected to a bus in order to deny service to any other device connected to that bus (represented by the l2Access predicate).', 1.0)).

interaction_rule(
 (dos(User, Host):-
  localAccess(User, Host, Account),
  localService(Host, Software, Account),
  vulHost(Host, VulID, Software, localExploit, dos),
  malicious(User)),
 rule_desc('Host-based DoS attacks. The attacker Principal (represented by the malicious predicate) exploits his/her login access to Host (represented by localAccess) which runs a vulnerable service that allows DoS (represented by the localService and vulHost).', 1.0)).

interaction_rule(
 (dos(User, DstHost):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, dos),
  malicious(User),
  netAccess5(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network. Network-based DoS attacks. The attacker Principal exploits his/her access to a network service running on DstHost (represented by the netAccess, aclH, and networkService), which contains a vulnerability that enables DoS upon successful exploitation (represented by the vulHost).', 1.0)).

interaction_rule(
 (dos(User, DstHost):-
  malicious(User),
  l2Access(User, SrcHost, DstHost, Prot, BusID, bus)),
 rule_desc('Attacks on Bus Communication; Malicious access to the bus.
Attacker Principal (represented by the malicious predicate) can utilize his/her local access (i.e., login or ability to execute code) to a device connected to a bus in order to deny service to any other device connected to that bus (represented by the l2Access predicate).', 1.0)).

interaction_rule(
 (dos(User, Host):-
  localAccess(User, Host, Account),
  localService(Host, Software, Account),
  vulHost(Host, VulID, Software, localExploit, dos),
  malicious(User)),
 rule_desc('Host-based DoS attacks. The attacker Principal (represented by the malicious predicate) exploits his/her login access to Host (represented by localAccess) which runs a vulnerable service that allows DoS (represented by the localService and vulHost).', 1.0)).

interaction_rule(
 (dos(User, DstHost):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, dos),
  malicious(User),
  netAccess5(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network. Network-based DoS attacks. The attacker Principal exploits his/her access to a network service running on DstHost (represented by the netAccess, aclH, and networkService), which contains a vulnerability that enables DoS upon successful exploitation (represented by the vulHost).', 1.0)).

interaction_rule(
 (dos(User, DstHost):-
  malicious(User),
  l2Access(User, SrcHost, DstHost, Prot, BusID, bus)),
 rule_desc('Attacks on Bus Communication; Malicious access to the bus.
Attacker Principal (represented by the malicious predicate) can utilize his/her local access (i.e., login or ability to execute code) to a device connected to a bus in order to deny service to any other device connected to that bus (represented by the l2Access predicate).', 1.0)).

interaction_rule(
 (mitmLink(User, SrcHost, DstHost, SpoofingHost):-
  spoofLinkHost(User, SrcHost, DstHost, SpoofingHost, trafficTheft),
  spoofLinkHost(User, DstHost, SrcHost, SpoofingHost, trafficTheft)),
 rule_desc('MITM attack in the link layer, in which the entire communication between SrcHost and DstHost is routed through the attackers host (SpoofingHost);', 1.0)).

interaction_rule(
 (relay(MITMHost, FlowName):-
  mitmLink(_User, SrcHost, DstHost, MITMHost),
  dataFlow(SrcHost, DstHost, FlowName, Direction)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(Host, Flowname):-
  relay(Host, SrcHost, DstHost, Prot, Port),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, Prot, Port)),
 rule_desc('Derive relay2 from relay5', 1.0)).

interaction_rule(
 (relay(SrcHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Source host is also relay host', 1.0)).

interaction_rule(
 (relay(DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Destination host is also relay host', 1.0)).

interaction_rule(
 (relay(AP, Flowname):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  l2Connection(AP, DstHost, Zone, ZoneProt, Type),
  isAP(AP, WirelessRange, Zone, WirelessProt, SecurityConf),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Deriving that an AP is a relay to a flow between hosts in the two zones it connects', 1.0)).

interaction_rule(
 (relay(MITMHost, FlowName):-
  mitmLink(_User, SrcHost, DstHost, MITMHost),
  dataFlow(SrcHost, DstHost, FlowName, Direction)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(Host, Flowname):-
  relay(Host, SrcHost, DstHost, Prot, Port),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, Prot, Port)),
 rule_desc('Derive relay2 from relay5', 1.0)).

interaction_rule(
 (relay(SrcHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Source host is also relay host', 1.0)).

interaction_rule(
 (relay(DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Destination host is also relay host', 1.0)).

interaction_rule(
 (relay(AP, Flowname):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  l2Connection(AP, DstHost, Zone, ZoneProt, Type),
  isAP(AP, WirelessRange, Zone, WirelessProt, SecurityConf),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Deriving that an AP is a relay to a flow between hosts in the two zones it connects', 1.0)).

interaction_rule(
 (relay(MITMHost, FlowName):-
  mitmLink(_User, SrcHost, DstHost, MITMHost),
  dataFlow(SrcHost, DstHost, FlowName, Direction)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(Host, Flowname):-
  relay(Host, SrcHost, DstHost, Prot, Port),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, Prot, Port)),
 rule_desc('Derive relay2 from relay5', 1.0)).

interaction_rule(
 (relay(SrcHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Source host is also relay host', 1.0)).

interaction_rule(
 (relay(DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Destination host is also relay host', 1.0)).

interaction_rule(
 (relay(AP, Flowname):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  l2Connection(AP, DstHost, Zone, ZoneProt, Type),
  isAP(AP, WirelessRange, Zone, WirelessProt, SecurityConf),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Deriving that an AP is a relay to a flow between hosts in the two zones it connects', 1.0)).

interaction_rule(
 (relay(MITMHost, FlowName):-
  mitmLink(_User, SrcHost, DstHost, MITMHost),
  dataFlow(SrcHost, DstHost, FlowName, Direction)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(Host, Flowname):-
  relay(Host, SrcHost, DstHost, Prot, Port),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, Prot, Port)),
 rule_desc('Derive relay2 from relay5', 1.0)).

interaction_rule(
 (relay(SrcHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Source host is also relay host', 1.0)).

interaction_rule(
 (relay(DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Destination host is also relay host', 1.0)).

interaction_rule(
 (relay(AP, Flowname):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  l2Connection(AP, DstHost, Zone, ZoneProt, Type),
  isAP(AP, WirelessRange, Zone, WirelessProt, SecurityConf),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Deriving that an AP is a relay to a flow between hosts in the two zones it connects', 1.0)).

interaction_rule(
 (relay(MITMHost, FlowName):-
  mitmLink(_User, SrcHost, DstHost, MITMHost),
  dataFlow(SrcHost, DstHost, FlowName, Direction)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(Host, Flowname):-
  relay(Host, SrcHost, DstHost, Prot, Port),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, Prot, Port)),
 rule_desc('Derive relay2 from relay5', 1.0)).

interaction_rule(
 (relay(SrcHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Source host is also relay host', 1.0)).

interaction_rule(
 (relay(DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('Destination host is also relay host', 1.0)).

interaction_rule(
 (relay(AP, Flowname):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  l2Connection(AP, DstHost, Zone, ZoneProt, Type),
  isAP(AP, WirelessRange, Zone, WirelessProt, SecurityConf),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Deriving that an AP is a relay to a flow between hosts in the two zones it connects', 1.0)).

interaction_rule(
 (mitmE2E(User, SrcHost, DstHost, SpoofingHost, Prot, Port):-
  spoofE2EHost(User, SrcHost, DstHost, SpoofingHost, Prot, Port, trafficTheft),
  spoofE2EHost(User, DstHost, SrcHost, SpoofingHost, Prot, Port, trafficTheft)),
 rule_desc('MITM attack in the end-to-end layer, in which only a specific application layer protocol (represented by the Port and Prot arguments) is routed through the attackers host.', 1.0)).

interaction_rule(
 (relay(MITMHost, SrcHost, DstHost, Prot, Port):-
  mitmE2E(_User, SrcHost, DstHost, MITMHost, Prot, Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(ImHost, SrcHost, DstHost, Prot, Port):-
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flonwname, Prot, Port),
  relay(ImHost, Flowname)),
 rule_desc('relay2 to relay5', 1.0)).

interaction_rule(
 (relay(MITMHost, SrcHost, DstHost, Prot, Port):-
  mitmE2E(_User, SrcHost, DstHost, MITMHost, Prot, Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(ImHost, SrcHost, DstHost, Prot, Port):-
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flonwname, Prot, Port),
  relay(ImHost, Flowname)),
 rule_desc('relay2 to relay5', 1.0)).

interaction_rule(
 (crackAPEncKey(User, _Host, AP):-
  malicious(User),
  accessDataFlow(User, Flowname, view),
  relay(AP, Flowname),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  vulLinkProtocol(WirelessRange, WeakEncryption, WirelessProt, remoteExploit, keyExtraction)),
 rule_desc('WEP Cracking; Utilizing wireless protocol with weak encryption to extract the encryption key of a device. In order to crack WEPs encryption, (1) the attacker must capture a large amount of legitimate packets transmitted to/from the access point; and (2) the access point must use the vulnerable WEP protocol.', 1.0)).

interaction_rule(
 (crackAPEncKey(User, _Host, AP):-
  malicious(User),
  isCredential(Flowname, AP, Account), 
  accessDataFlow(User, Flowname, view),
  relay(AP, Flowname),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  vulLinkProtocol(WirelessRange, WeakEncryption, WirelessProt, remoteExploit, keyExtraction)),
 rule_desc('Utilizing wireless protocol with weak encryption to extract the encryption key of a device', 1.0)).

interaction_rule(
 (crackAPEncKey(User, Host, AP):-
  malicious(User),
  accessLinkFlow(User, Host, AP, Protocol, read),
  isAP5AP, WirelessRange, DstZone, Protocol, secured),
  vulLinkProtocol(WirelessRange, VulID1, Protocol, adjacent, keyReinstallation),
  vulHost(Host, VulID2, wpaSupplicant, localExploit, keyExtraction)),
 rule_desc('An additional vulnerability in several WPA2 implementations that reinstall an all-zero encryption key upon retransmission of 3rd handshake message.', 1.0)).

interaction_rule(
 (crackAPEncKey(User, _Host, AP):-
  malicious(User),
  accessDataFlow(User, Flowname, view),
  relay(AP, Flowname),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  vulLinkProtocol(WirelessRange, WeakEncryption, WirelessProt, remoteExploit, keyExtraction)),
 rule_desc('WEP Cracking; Utilizing wireless protocol with weak encryption to extract the encryption key of a device. In order to crack WEPs encryption, (1) the attacker must capture a large amount of legitimate packets transmitted to/from the access point; and (2) the access point must use the vulnerable WEP protocol.', 1.0)).

interaction_rule(
 (crackAPEncKey(User, _Host, AP):-
  malicious(User),
  isCredential(Flowname, AP, Account), 
  accessDataFlow(User, Flowname, view),
  relay(AP, Flowname),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  vulLinkProtocol(WirelessRange, WeakEncryption, WirelessProt, remoteExploit, keyExtraction)),
 rule_desc('Utilizing wireless protocol with weak encryption to extract the encryption key of a device', 1.0)).

interaction_rule(
 (crackAPEncKey(User, Host, AP):-
  malicious(User),
  accessLinkFlow(User, Host, AP, Protocol, read),
  isAP5AP, WirelessRange, DstZone, Protocol, secured),
  vulLinkProtocol(WirelessRange, VulID1, Protocol, adjacent, keyReinstallation),
  vulHost(Host, VulID2, wpaSupplicant, localExploit, keyExtraction)),
 rule_desc('An additional vulnerability in several WPA2 implementations that reinstall an all-zero encryption key upon retransmission of 3rd handshake message.', 1.0)).

interaction_rule(
 (crackAPEncKey(User, _Host, AP):-
  malicious(User),
  accessDataFlow(User, Flowname, view),
  relay(AP, Flowname),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  vulLinkProtocol(WirelessRange, WeakEncryption, WirelessProt, remoteExploit, keyExtraction)),
 rule_desc('WEP Cracking; Utilizing wireless protocol with weak encryption to extract the encryption key of a device. In order to crack WEPs encryption, (1) the attacker must capture a large amount of legitimate packets transmitted to/from the access point; and (2) the access point must use the vulnerable WEP protocol.', 1.0)).

interaction_rule(
 (crackAPEncKey(User, _Host, AP):-
  malicious(User),
  isCredential(Flowname, AP, Account), 
  accessDataFlow(User, Flowname, view),
  relay(AP, Flowname),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  vulLinkProtocol(WirelessRange, WeakEncryption, WirelessProt, remoteExploit, keyExtraction)),
 rule_desc('Utilizing wireless protocol with weak encryption to extract the encryption key of a device', 1.0)).

interaction_rule(
 (crackAPEncKey(User, Host, AP):-
  malicious(User),
  accessLinkFlow(User, Host, AP, Protocol, read),
  isAP5AP, WirelessRange, DstZone, Protocol, secured),
  vulLinkProtocol(WirelessRange, VulID1, Protocol, adjacent, keyReinstallation),
  vulHost(Host, VulID2, wpaSupplicant, localExploit, keyExtraction)),
 rule_desc('An additional vulnerability in several WPA2 implementations that reinstall an all-zero encryption key upon retransmission of 3rd handshake message.', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (isAuthenticated(User, AttackerHost, AP):-
  crackAPEncKey(User, _Host, AP),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  localAccess(User, AttackerHost, admin),
  located(AttackerHost, WirelessRange, physical)),
 rule_desc('By cracking the encryption key, the attacker can authenticate to the access point.', 1.0)).

interaction_rule(
 (accessLinkFlow(User, Host, AP, Protocol, read):-
  malicious(User),
  localAccess(User, AttackerHost, admin),
  located(AttackerHost, WirelessRange, physical),
  flowBind(Flowname, Protocol, Port),
  isCredential(Flowname, DstZone, Account),
  vulLinkProtocol(WirelessRange, VulID, Protocol, adjacent, keyReinstallation),
  isAP(AP, WirelessRange, DstZone, Protocol, secured),
  located(Host, WirelessRange, physical)),
 rule_desc('WPA2 Key Reinstallation. (1) The attacker becomes a MITM between the host and the access point (e.g., by channel-based MITM technique); and (2) the attacker prevents the 4th handshake message from reaching the access point, which causes the retransmission of the 3rd message.', 1.0)).

interaction_rule(
 (crackPINCode(User, SrcHost, DstHost, BluetoothProt):-
  malicious(User),
  accessDataFlow(User, Flowname, read),
  isPairingProcess(Flowname),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port)),
 rule_desc('Bluetooth PIN Cracking; Principal got the PIN code of the Bluetooth communication. The attacker Principal (represented by the malicious predicate) can read the messages exchanged by two devices (represented by the accessDataFlow, dataFlow, and flowBind) during their pairing process (represented by the isPairingProcess).', 1.0)).

interaction_rule(
 (crackPINCode(User, DstHost, SrcHost, BluetoothProt):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt)),
 rule_desc('Principal got the PIN code of the Bluetooth communication', 1.0)).

interaction_rule(
 (crackPINCode(User, SrcHost, DstHost, BluetoothProt):-
  malicious(User),
  accessDataFlow(User, Flowname, read),
  isPairingProcess(Flowname),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port)),
 rule_desc('Bluetooth PIN Cracking; Principal got the PIN code of the Bluetooth communication. The attacker Principal (represented by the malicious predicate) can read the messages exchanged by two devices (represented by the accessDataFlow, dataFlow, and flowBind) during their pairing process (represented by the isPairingProcess).', 1.0)).

interaction_rule(
 (crackPINCode(User, DstHost, SrcHost, BluetoothProt):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt)),
 rule_desc('Principal got the PIN code of the Bluetooth communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (dataFlow(SrcHost, Flowname):-
  dataFlow(SrcHost, _DstHost, Flowname, _Direction)),
 rule_desc('dataFlow related to source host', 1.0)).

interaction_rule(
 (dataFlow(DstHost, Flowname):-
  dataFlow(_SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('dataFlow related to end host', 1.0)).

interaction_rule(
 (dataFlow(SrcHost, Flowname):-
  dataFlow(SrcHost, _DstHost, Flowname, _Direction)),
 rule_desc('dataFlow related to source host', 1.0)).

interaction_rule(
 (dataFlow(DstHost, Flowname):-
  dataFlow(_SrcHost, DstHost, Flowname, _Direction)),
 rule_desc('dataFlow related to end host', 1.0)).

interaction_rule(
 (dataFlow(SrcHost, DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, oneWay)),
 rule_desc('One way dataFlow primitive', 1.0)).

interaction_rule(
 (dataFlow(DstHost, SrcHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, twoWay)),
 rule_desc('Two way dataFlow primitive', 1.0)).

interaction_rule(
 (dataFlow(SrcHost, DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, twoWay)),
 rule_desc('Two way dataFlow primitive', 1.0)).

interaction_rule(
 (dataFlow(SrcHost, DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, oneWay)),
 rule_desc('One way dataFlow primitive', 1.0)).

interaction_rule(
 (dataFlow(DstHost, SrcHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, twoWay)),
 rule_desc('Two way dataFlow primitive', 1.0)).

interaction_rule(
 (dataFlow(SrcHost, DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, twoWay)),
 rule_desc('Two way dataFlow primitive', 1.0)).

interaction_rule(
 (dataFlow(SrcHost, DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, oneWay)),
 rule_desc('One way dataFlow primitive', 1.0)).

interaction_rule(
 (dataFlow(DstHost, SrcHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, twoWay)),
 rule_desc('Two way dataFlow primitive', 1.0)).

interaction_rule(
 (dataFlow(SrcHost, DstHost, Flowname):-
  dataFlow(SrcHost, DstHost, Flowname, twoWay)),
 rule_desc('Two way dataFlow primitive', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (dataInject(User, DstHost, Path2):-
  accessFile(User, SrcHost, write, Path1),
  dataBind(Flow, SrcHost, Path1),
  dataFlow(SrcHost, DstHost, Flow, _Direction),
  dataBind (Flow, DstHost, Path2)),
 rule_desc('Principal can inject data to Path2 on DstHost.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hostImpact(VM) :-
  residencyDepend(Vm, Host),
  hostImpact(Host)),
 rule_desc('A compromised host will impact the dependent virtual machines.', 1.0)).

interaction_rule(
 (serviceImpacted(Service, Host, Account) :-
  hostProvideService(Host, Service),
  execCode(_User, Host, Account)),
 rule_desc('A compromised server will impact the dependent service.', 1.0)).

interaction_rule(
 (imageVulExists(VMI_id, stealthyBridge_id, _Software, remoteExploit, privEscalation):-
  isThirdPartyImage(VMI_id)),
 rule_desc('A third party VMI could contain a stealthy bridge.', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, VulID, Software),
  vulProperty(VulID, Range, Consequence)),
 rule_desc('A vulnerability exists in the Program on a Host, and it has specific ExploitRange and ExploitConsequence.
Program is the full path of the executable that contains the security bug.', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, ExploitRange, ExploitConsequence):-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('Hypothetical Bug', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, _VulID, DependedSoftware, Range, Consequence),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('Library Bug', 1.0)).

interaction_rule(
 (vulExists(Vm_id, vulID, _Software, _Range, _Consequence) :-
  imageVulExists(VMI_id, vulID, _Software, _Range, _Consequence),
  isInstance(Vm_id, VMI_id)),
 rule_desc('A virtual machine instance inherits the vulnerability from the parent VMI.', 1.0)).

interaction_rule(
 (vulExists(Host, VulID, Sw, ExploitRange, ExploitConsequence) :-
  vulExists(Host, VulID, Sw),
  vulProperty(VulID, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (imageVulExists(VMI_id, stealthyBridge_id, _Software, remoteExploit, privEscalation):-
  isThirdPartyImage(VMI_id)),
 rule_desc('A third party VMI could contain a stealthy bridge.', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (leakInfo(Host) :-
  leakInfo(Host, _Info)),
 rule_desc('Leaking information', 1.0)).

interaction_rule(
 (leakInfo(Host, code) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readcode)),
 rule_desc('Leaking code information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, file) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readfile)),
 rule_desc('Leaking file information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, data) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readdata)),
 rule_desc('Leaking data information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, code) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readcode)),
 rule_desc('Leaking code information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, file) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readfile)),
 rule_desc('Leaking file information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, data) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readdata)),
 rule_desc('Leaking data information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, code) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readcode)),
 rule_desc('Leaking code information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, file) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readfile)),
 rule_desc('Leaking file information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, data) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readdata)),
 rule_desc('Leaking data information due to a vulnerability', 1.0)).

interaction_rule(
 (tamperInfo(Host, Resource) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, Action),
  modifyInfoAct(Action, Resource)),
 rule_desc('Tampering data information due to a vulnerability', 1.0)).

interaction_rule(
 (execCode(Host, root) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, Action),
  canLeadToPrivEscalation(Action)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Software, Processor) :-
  process(Software, Processor, _Os),
  execCode(Software2, Processor2),
  memoryMap(Processor, Processor2, InitRange, EndRange),
  accessMemory(Software2, InitRange, EndRange)),
 rule_desc('An attacker can gain the ability to execute arbitrary code on a Process if he can do so on Process2, the two processors are connected by memory mapping, and Process2 can access the mapped memory range.', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (systemDown(Host) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, localExploit, overuse),
  misuseAction(overuse)),
 rule_desc('Local DOS', 1.0)).

interaction_rule(
 (systemDown(Host) :-
  vulExists(Host, _VulID, Software, remoteExploit, overuse),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port),
  misuseAction(overuse)),
 rule_desc('Remote DOS on a server program', 1.0)).

interaction_rule(
 (systemDown(Host) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, localExploit, overuse),
  misuseAction(overuse)),
 rule_desc('Local DOS', 1.0)).

interaction_rule(
 (systemDown(Host) :-
  vulExists(Host, _VulID, Software, remoteExploit, overuse),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port),
  misuseAction(overuse)),
 rule_desc('Remote DOS on a server program', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, VulID, Software),
  vulProperty(VulID, Range, Consequence)),
 rule_desc('A vulnerability exists in the Program on a Host, and it has specific ExploitRange and ExploitConsequence.
Program is the full path of the executable that contains the security bug.', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, ExploitRange, ExploitConsequence):-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('Hypothetical Bug', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, _VulID, DependedSoftware, Range, Consequence),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('Library Bug', 1.0)).

interaction_rule(
 (vulExists(Vm_id, vulID, _Software, _Range, _Consequence) :-
  imageVulExists(VMI_id, vulID, _Software, _Range, _Consequence),
  isInstance(Vm_id, VMI_id)),
 rule_desc('A virtual machine instance inherits the vulnerability from the parent VMI.', 1.0)).

interaction_rule(
 (vulExists(Host, VulID, Sw, ExploitRange, ExploitConsequence) :-
  vulExists(Host, VulID, Sw),
  vulProperty(VulID, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, VulID, Software),
  vulProperty(VulID, Range, Consequence)),
 rule_desc('A vulnerability exists in the Program on a Host, and it has specific ExploitRange and ExploitConsequence.
Program is the full path of the executable that contains the security bug.', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, ExploitRange, ExploitConsequence):-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('Hypothetical Bug', 1.0)).

interaction_rule(
 (vulExists(Host, _VulID, Software, Range, Consequence):-
  vulExists(Host, _VulID, DependedSoftware, Range, Consequence),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('Library Bug', 1.0)).

interaction_rule(
 (vulExists(Vm_id, vulID, _Software, _Range, _Consequence) :-
  imageVulExists(VMI_id, vulID, _Software, _Range, _Consequence),
  isInstance(Vm_id, VMI_id)),
 rule_desc('A virtual machine instance inherits the vulnerability from the parent VMI.', 1.0)).

interaction_rule(
 (vulExists(Host, VulID, Sw, ExploitRange, ExploitConsequence) :-
  vulExists(Host, VulID, Sw),
  vulProperty(VulID, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (canReceiveFile(HostRX, HostTX, FileName) :-
  notSame(HostRX, HostTX),
  vulExists(HostTX, _VulID, Software, remoteExploit, spoofResponse),
  networkService(HostTX, Software, Protocol, Port, _Account),
  netAccess(_User, HostTX, HostRX, Protocol, Port),
  execCode(_User, HostRX, _Account),
  sendsFile(HostTX, _Host, FileName, Software)),
 rule_desc('Spoofed broadcast querry response allows receiving file intended for other host', 1.0)).

interaction_rule(
 (canReceiveFile(HostRX, HostTX, FileName) :-
  notSame(HostRX, HostTX),
  vulExists(HostTX, _VulID, Software, remoteExploit, spoofResponse),
  networkService(HostTX, Software, Protocol, Port, _Account),
  netAccess(_User, HostTX, HostRX, Protocol, Port),
  attackerLocated(HostRX),
  sendsFile(HostTX, _Host, FileName, Software)),
 rule_desc('Spoofed broadcast querry response allows receiving file intended for other host', 1.0)).

interaction_rule(
 (canReceiveFile(HostRX, HostTX, FileName) :-
  notSame(HostRX, HostTX),
  vulExists(HostTX, _VulID, Software, remoteExploit, spoofResponse),
  networkService(HostTX, Software, Protocol, Port, _Account),
  netAccess(_User, HostTX, HostRX, Protocol, Port),
  execCode(_User, HostRX, _Account),
  sendsFile(HostTX, _Host, FileName, Software)),
 rule_desc('Spoofed broadcast querry response allows receiving file intended for other host', 1.0)).

interaction_rule(
 (canReceiveFile(HostRX, HostTX, FileName) :-
  notSame(HostRX, HostTX),
  vulExists(HostTX, _VulID, Software, remoteExploit, spoofResponse),
  networkService(HostTX, Software, Protocol, Port, _Account),
  netAccess(_User, HostTX, HostRX, Protocol, Port),
  attackerLocated(HostRX),
  sendsFile(HostTX, _Host, FileName, Software)),
 rule_desc('Spoofed broadcast querry response allows receiving file intended for other host', 1.0)).

interaction_rule(
 (canSendFile(SrcHost, TgtHost, Software) :-
  attackerLocated(SrcHost),
  vulExists(TgtHost, _VulID, Software, remoteExploit, noAuthentication),
  networkService(TgtHost, Software, Protocol, Port, _Account),
  netAccess(_User, SrcHost, TgtHost, Protocol, Port),
  listenForFiles(TgtHost, Software)),
 rule_desc('Send file to listening server without authentication', 1.0)).

interaction_rule(
 (canSendFile(SrcHost, TgtHost, Software) :-
  execCode(_User, SrcHost, _Account),
  vulExists(TgtHost, _VulID, Software, remoteExploit, noAuthentication),
  networkService(TgtHost, Software, Protocol, Port, _Account),
  netAccess(_User, SrcHost, TgtHost, Protocol, Port),
  listenForFiles(TgtHost, Software)),
 rule_desc('Compromised host can send file to listening server without authentication', 1.0)).

interaction_rule(
 (canSendFile(SrcHost, TgtHost, Software) :-
  attackerLocated(SrcHost),
  vulExists(TgtHost, _VulID, Software, remoteExploit, noAuthentication),
  networkService(TgtHost, Software, Protocol, Port, _Account),
  netAccess(_User, SrcHost, TgtHost, Protocol, Port),
  listenForFiles(TgtHost, Software)),
 rule_desc('Send file to listening server without authentication', 1.0)).

interaction_rule(
 (canSendFile(SrcHost, TgtHost, Software) :-
  execCode(_User, SrcHost, _Account),
  vulExists(TgtHost, _VulID, Software, remoteExploit, noAuthentication),
  networkService(TgtHost, Software, Protocol, Port, _Account),
  netAccess(_User, SrcHost, TgtHost, Protocol, Port),
  listenForFiles(TgtHost, Software)),
 rule_desc('Compromised host can send file to listening server without authentication', 1.0)).

interaction_rule(
 (canDoS(SrcHost, TgtHost, Software) :-
  vulExists(TgtHost, _VulID, Software, remoteExploit, poorCongestionControl),
  canSendFile(SrcHost, TgtHost, Software)),
 rule_desc('DoS server by overwhelming congestion control', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  sendsFile(TxHost, RxHost, FileName, _Software),
  dataTransitsThrough(Host, FileName),
  execCode(_User, Host, _Account)),
 rule_desc('Man in the Middle Situation by network position', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  execCode(_User, Host, _Account),
  canReceiveFile(Host, TxHost, FileName),
  canSendFile(Host, RxHost, _Software)),
 rule_desc('Man in the Middle Situation by compromised host', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  attackerLocated(Host),
  canReceiveFile(Host, TxHost, FileName),
  canSendFile(Host, RxHost, _Software)),
 rule_desc('Man in the Middle Situation by compromised host', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  sendsFile(TxHost, RxHost, FileName, _Software),
  dataTransitsThrough(Host, FileName),
  execCode(_User, Host, _Account)),
 rule_desc('Man in the Middle Situation by network position', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  execCode(_User, Host, _Account),
  canReceiveFile(Host, TxHost, FileName),
  canSendFile(Host, RxHost, _Software)),
 rule_desc('Man in the Middle Situation by compromised host', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  attackerLocated(Host),
  canReceiveFile(Host, TxHost, FileName),
  canSendFile(Host, RxHost, _Software)),
 rule_desc('Man in the Middle Situation by compromised host', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  sendsFile(TxHost, RxHost, FileName, _Software),
  dataTransitsThrough(Host, FileName),
  execCode(_User, Host, _Account)),
 rule_desc('Man in the Middle Situation by network position', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  execCode(_User, Host, _Account),
  canReceiveFile(Host, TxHost, FileName),
  canSendFile(Host, RxHost, _Software)),
 rule_desc('Man in the Middle Situation by compromised host', 1.0)).

interaction_rule(
 (manInTheMiddle(Host, TxHost, RxHost) :-
  attackerLocated(Host),
  canReceiveFile(Host, TxHost, FileName),
  canSendFile(Host, RxHost, _Software)),
 rule_desc('Man in the Middle Situation by compromised host', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, _AtkHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, Host) :-
  notSame(Host, TgtHost),
  notSame(Host, AtkHost),
  attackerLocated(AtkHost),
  netAccess(AtkHost, _SrcHost, Host, _Protocol, _Port),
  pivotPoint(Host, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canSendFile(AtkHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canSendFile(SrcHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost,  _Protocol ,_Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, _AtkHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, Host) :-
  notSame(Host, TgtHost),
  notSame(Host, AtkHost),
  attackerLocated(AtkHost),
  netAccess(AtkHost, _SrcHost, Host, _Protocol, _Port),
  pivotPoint(Host, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canSendFile(AtkHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canSendFile(SrcHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost,  _Protocol ,_Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, _AtkHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, Host) :-
  notSame(Host, TgtHost),
  notSame(Host, AtkHost),
  attackerLocated(AtkHost),
  netAccess(AtkHost, _SrcHost, Host, _Protocol, _Port),
  pivotPoint(Host, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canSendFile(AtkHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canSendFile(SrcHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost,  _Protocol ,_Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, _AtkHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, Host) :-
  notSame(Host, TgtHost),
  notSame(Host, AtkHost),
  attackerLocated(AtkHost),
  netAccess(AtkHost, _SrcHost, Host, _Protocol, _Port),
  pivotPoint(Host, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canSendFile(AtkHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canSendFile(SrcHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost,  _Protocol ,_Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, _AtkHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, Host) :-
  notSame(Host, TgtHost),
  notSame(Host, AtkHost),
  attackerLocated(AtkHost),
  netAccess(AtkHost, _SrcHost, Host, _Protocol, _Port),
  pivotPoint(Host, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canSendFile(AtkHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canSendFile(SrcHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost,  _Protocol ,_Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, _AtkHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, Host) :-
  notSame(Host, TgtHost),
  notSame(Host, AtkHost),
  attackerLocated(AtkHost),
  netAccess(AtkHost, _SrcHost, Host, _Protocol, _Port),
  pivotPoint(Host, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Defective parts -- execute code', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canSendFile(AtkHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canSendFile(SrcHost, TgtHost, _Software)),
 rule_desc('Defective parts -- RX from unauthorized', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToMakingDefectiveParts(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost,  _Protocol ,_Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Defective parts -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost), 
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, MiddleHost) :-
  notSame(MIddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Susceptible to data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canReceiveFile(AtkHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canReceiveFile(SrcHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost), 
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, MiddleHost) :-
  notSame(MIddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Susceptible to data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canReceiveFile(AtkHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canReceiveFile(SrcHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost), 
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, MiddleHost) :-
  notSame(MIddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Susceptible to data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canReceiveFile(AtkHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canReceiveFile(SrcHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost), 
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, MiddleHost) :-
  notSame(MIddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Susceptible to data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canReceiveFile(AtkHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canReceiveFile(SrcHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost), 
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, MiddleHost) :-
  notSame(MIddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Susceptible to data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canReceiveFile(AtkHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canReceiveFile(SrcHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost), 
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, MiddleHost) :-
  notSame(MIddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('Susceptible to data exfiltration -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canReceiveFile(AtkHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _DstHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canReceiveFile(SrcHost, TgtHost, _FileName)),
 rule_desc('Data exfiltration -- TX unauthorized', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDataExfiltration(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('Data exfiltration -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, MiddleHost) :-
  notSame(MiddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canDoS(AtkHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canDoS(SrcHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, MiddleHost) :-
  notSame(MiddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canDoS(AtkHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canDoS(SrcHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, MiddleHost) :-
  notSame(MiddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canDoS(AtkHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canDoS(SrcHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, MiddleHost) :-
  notSame(MiddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canDoS(AtkHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canDoS(SrcHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, MiddleHost) :-
  notSame(MiddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canDoS(AtkHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canDoS(SrcHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(_User, SrcHost, TgtHost, _Protocol, _Port),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, MiddleHost) :-
  notSame(MiddleHost, TgtHost),
  notSame(MiddleHost, AtkHost),
  attackerLocated(AtkHost),
  netAccess(_User, AtkHost, MiddleHost, _Protocol, _Port),
  pivotPoint(MiddleHost, TgtHost),
  execCode(_User, TgtHost, _Account)),
 rule_desc('DoS -- execute code', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  canDoS(AtkHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  canDoS(SrcHost, TgtHost, _Software)),
 rule_desc('DoS -- DoS', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, AtkHost) :-
  attackerLocated(AtkHost),
  notSame(AtkHost, TgtHost),
  manInTheMiddle(AtkHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (vulnerableToDoS(TgtHost, SrcHost) :-
  attackerLocated(SrcHost),
  netAccess(Attacker, SrcHost, TgtHost, _Protocol, _Port),
  notSame(SrcHost, TgtHost),
  manInTheMiddle(SrcHost, _Host, TgtHost)),
 rule_desc('DoS -- MitM', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (areColocated(Vm1, Vm2) :-
  instantiate(Host, Vm1),
  instantiate(Host, Vm2)),
 rule_desc('vm1 and vm2 belong to the same hypervisor.', 1.0)).

interaction_rule(
 (isInSubnet(Subnet, Vm) :-
  isAttachedTo(Vp1vm, Vm),
  isAttachedTo(Vp1vm, Subnet)),
 rule_desc('The VM vm is in the (virtual) subnet s', 1.0)).

interaction_rule(
 (areRouted(Router, Subnet1, Subnet2) :-
  isAttachedTo(Vp1r, Router),
  isAttachedTo(Vp1r, Subnet1),
  isAttachedTo(Vp2r, Router),
  isAttachedTo(Vp2r, Subnet2)),
 rule_desc('The subnets s1 and s2 are connected via the (virtual) router r', 1.0)).

interaction_rule(
 (areConnected(Vm1, Vm2) :-
  contains(SecurityGroup, _SecurityRule),
  isEnforcedOn(SecurityGroup, Vm2),
  areRouted(Router, Subnet1, Subnet2),
  isInSubnet(Subnet1, Vm1),
  hasIP(IPsrc, Vm1),
  isInSubnet(Subnet2, Vm2),
  hasIP(IPdst, Vm2),
  isInSubnet(Subnet1, IPsrc),
  isInSubnet(Subnet2, IPdst)),
 rule_desc('The virtual machines x and y are either on the same subnet or on subnets linked by routers, and their security rules allow communication for at least one combination of addresses, ports and protocol.', 1.0)).

interaction_rule(
 (areConnected(Vm1, Vm2) :-
  contains(SecurityGroup, _SecurityRule),
  isEnforcedOn(SecurityGroup, Vm2),
  isInSubnet(Subnet, Vm1),
  hasIP(IPsrc, Vm1),
  isInSubnet(Subnet, Vm2),
  hasIP(IPdst, Vm2),
  isInSubnet(Subnet1, IPsrc),
  isInSubnet(Subnet2, IPdst)),
 rule_desc('', 1.0)).

interaction_rule(
 (areConnected(Vm1, Vm2) :-
  contains(SecurityGroup, _SecurityRule),
  isEnforcedOn(SecurityGroup, Vm2),
  areRouted(Router, Subnet1, Subnet2),
  isInSubnet(Subnet1, Vm1),
  hasIP(IPsrc, Vm1),
  isInSubnet(Subnet2, Vm2),
  hasIP(IPdst, Vm2),
  isInSubnet(Subnet1, IPsrc),
  isInSubnet(Subnet2, IPdst)),
 rule_desc('The virtual machines x and y are either on the same subnet or on subnets linked by routers, and their security rules allow communication for at least one combination of addresses, ports and protocol.', 1.0)).

interaction_rule(
 (areConnected(Vm1, Vm2) :-
  contains(SecurityGroup, _SecurityRule),
  isEnforcedOn(SecurityGroup, Vm2),
  isInSubnet(Subnet, Vm1),
  hasIP(IPsrc, Vm1),
  isInSubnet(Subnet, Vm2),
  hasIP(IPdst, Vm2),
  isInSubnet(Subnet1, IPsrc),
  isInSubnet(Subnet2, IPdst)),
 rule_desc('', 1.0)).

interaction_rule(
 (mulvalCheckAccess(allowed, fileACL(_FileName, _Owner, dacl(null)), RequestedAccess, _Software) :-
  validAccess(RequestedAccess)),
 rule_desc('No ACL implies no protection. If a file does not have an Access Control List ("Null DACL"), then any access is permitted on the file.', 1.0)).

interaction_rule(
 (mulvalCheckAccess(allowed, fileACL(_FileName, owner(Owner), _Dacl), RequestedAccess, Software) :-
  validAccess(RequestedAccess),
  getProcessOwner(Software, Owner)),
 rule_desc('Owner always gets access. The owner of a file always gets WRITE DAC access to the file. The owner can use the WRITE DAC permission to reset the fle system ACLs. Thus an owner always get access to the file.', 1.0)).

interaction_rule(
 (mulvalCheckAccess(allowed, fileACL(_FileName, _Owner, dacl(null)), RequestedAccess, _Software) :-
  validAccess(RequestedAccess)),
 rule_desc('No ACL implies no protection. If a file does not have an Access Control List ("Null DACL"), then any access is permitted on the file.', 1.0)).

interaction_rule(
 (mulvalCheckAccess(allowed, fileACL(_FileName, owner(Owner), _Dacl), RequestedAccess, Software) :-
  validAccess(RequestedAccess),
  getProcessOwner(Software, Owner)),
 rule_desc('Owner always gets access. The owner of a file always gets WRITE DAC access to the file. The owner can use the WRITE DAC permission to reset the fle system ACLs. Thus an owner always get access to the file.', 1.0)).

interaction_rule(
 (checkAccess(allowed, _FileDacl, RequestedAccess, Software) :-
  validAccess(RequestedAccess),
  getProcessPrivileges(Software, Permissions),
  hasSuperPrivilege(true, Permissions)),
 rule_desc('The adversary having any of the super privileges results in he getting access to any file.', 1.0)).

interaction_rule(
 (canAccess (User, Permission, Resource) :-
  member (User, Group),
  canAccess (Group, Permission, Resource)),
 rule_desc('If Principal belongs to Group, he gets any permission that the group can get.', 1.0)).

interaction_rule(
 (canAccess (_OtherUser, _Permission, Resource) :-
  principalCompromised (User),
  canAccess (User, write_dac, Resource)),
 rule_desc('if Principal has the WRITE DAC ("write discretionary access-control list") permission on the resource, they can make any OtherPrincipal have any Permission on the resource.', 1.0)).

interaction_rule(
 (canAccess (User, Permission, Resource) :-
  member (User, Group),
  canAccess (Group, Permission, Resource)),
 rule_desc('If Principal belongs to Group, he gets any permission that the group can get.', 1.0)).

interaction_rule(
 (canAccess (_OtherUser, _Permission, Resource) :-
  principalCompromised (User),
  canAccess (User, write_dac, Resource)),
 rule_desc('if Principal has the WRITE DAC ("write discretionary access-control list") permission on the resource, they can make any OtherPrincipal have any Permission on the resource.', 1.0)).

interaction_rule(
 (principalCompromised (_User) :-
  principalCompromised (Attacker),
  canAccess (Attacker, service_change_config, Service)),
 rule_desc('If you have been compromised by the attacker, and your account can change the service configuration of a Service to run the attacker's .EXE file in a process owned by Principal, then you can compromise that Principal.', 1.0)).

interaction_rule(
 (principalCompromised (User) :-
  principalCompromised (Attacker),
  canAccess (Attacker, write, File),
  canAccess (User, execute, File)),
 rule_desc('If you can write to a file that some Principal can execute, then you can install a Trojan Horse that makes that Principal act on your behalf.', 1.0)).

interaction_rule(
 (principalCompromised (_User) :-
  principalCompromised (Attacker),
  canAccess (Attacker, service_change_config, Service)),
 rule_desc('If you have been compromised by the attacker, and your account can change the service configuration of a Service to run the attacker's .EXE file in a process owned by Principal, then you can compromise that Principal.', 1.0)).

interaction_rule(
 (principalCompromised (User) :-
  principalCompromised (Attacker),
  canAccess (Attacker, write, File),
  canAccess (User, execute, File)),
 rule_desc('If you can write to a file that some Principal can execute, then you can install a Trojan Horse that makes that Principal act on your behalf.', 1.0)).

interaction_rule(
 (windowsAccessCheck(denied, SecurityDescriptor, RequestedAccess, ProcessToken) :-
  not windowsAccessCheck(allowed, SecurityDescriptor, RequestedAccess, ProcessToken)),
 rule_desc('Everything else is denied.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, WRITE_DAC, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, GENERIC_WRITE, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(file, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, FILE_WRITE_DATA, ProcessToken)),
 rule_desc('If the adversary has FILE WRITE DATA permission on a file, he could overwrite the file.', 1.0)).

interaction_rule(
 (canWrite(User, resource(registry, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, KEY_SET_VALUE, ProcessToken)),
 rule_desc('If the adversary has KEY SET VALUE permission on a registry key, he could overwrite the contents of the key.', 1.0)).

interaction_rule(
 (canWrite(User, resource(service, Name, Dacl)) :-
  userToken(User, Token),
  windowsAccessCheck(allowed, Dacl, SERVICE_CHANGE_CONFIG, Token)),
 rule_desc('If the adversary has SERVICE CHANGE CONFIG permission on a service, he could reconfigure the service.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, WRITE_DAC, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, GENERIC_WRITE, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(file, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, FILE_WRITE_DATA, ProcessToken)),
 rule_desc('If the adversary has FILE WRITE DATA permission on a file, he could overwrite the file.', 1.0)).

interaction_rule(
 (canWrite(User, resource(registry, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, KEY_SET_VALUE, ProcessToken)),
 rule_desc('If the adversary has KEY SET VALUE permission on a registry key, he could overwrite the contents of the key.', 1.0)).

interaction_rule(
 (canWrite(User, resource(service, Name, Dacl)) :-
  userToken(User, Token),
  windowsAccessCheck(allowed, Dacl, SERVICE_CHANGE_CONFIG, Token)),
 rule_desc('If the adversary has SERVICE CHANGE CONFIG permission on a service, he could reconfigure the service.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, WRITE_DAC, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, GENERIC_WRITE, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(file, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, FILE_WRITE_DATA, ProcessToken)),
 rule_desc('If the adversary has FILE WRITE DATA permission on a file, he could overwrite the file.', 1.0)).

interaction_rule(
 (canWrite(User, resource(registry, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, KEY_SET_VALUE, ProcessToken)),
 rule_desc('If the adversary has KEY SET VALUE permission on a registry key, he could overwrite the contents of the key.', 1.0)).

interaction_rule(
 (canWrite(User, resource(service, Name, Dacl)) :-
  userToken(User, Token),
  windowsAccessCheck(allowed, Dacl, SERVICE_CHANGE_CONFIG, Token)),
 rule_desc('If the adversary has SERVICE CHANGE CONFIG permission on a service, he could reconfigure the service.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, WRITE_DAC, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, GENERIC_WRITE, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(file, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, FILE_WRITE_DATA, ProcessToken)),
 rule_desc('If the adversary has FILE WRITE DATA permission on a file, he could overwrite the file.', 1.0)).

interaction_rule(
 (canWrite(User, resource(registry, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, KEY_SET_VALUE, ProcessToken)),
 rule_desc('If the adversary has KEY SET VALUE permission on a registry key, he could overwrite the contents of the key.', 1.0)).

interaction_rule(
 (canWrite(User, resource(service, Name, Dacl)) :-
  userToken(User, Token),
  windowsAccessCheck(allowed, Dacl, SERVICE_CHANGE_CONFIG, Token)),
 rule_desc('If the adversary has SERVICE CHANGE CONFIG permission on a service, he could reconfigure the service.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, WRITE_DAC, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(Type, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, GENERIC_WRITE, ProcessToken)),
 rule_desc('If the adversary has WRITE DAC or GENERIC WRITE permissions, he can write to the resource.', 1.0)).

interaction_rule(
 (canWrite(User, resource(file, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, FILE_WRITE_DATA, ProcessToken)),
 rule_desc('If the adversary has FILE WRITE DATA permission on a file, he could overwrite the file.', 1.0)).

interaction_rule(
 (canWrite(User, resource(registry, Name, Dacl)) :-
  userToken(User, ProcessToken),
  windowsAccessCheck(allowed, Dacl, KEY_SET_VALUE, ProcessToken)),
 rule_desc('If the adversary has KEY SET VALUE permission on a registry key, he could overwrite the contents of the key.', 1.0)).

interaction_rule(
 (canWrite(User, resource(service, Name, Dacl)) :-
  userToken(User, Token),
  windowsAccessCheck(allowed, Dacl, SERVICE_CHANGE_CONFIG, Token)),
 rule_desc('If the adversary has SERVICE CHANGE CONFIG permission on a service, he could reconfigure the service.', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (dependsOn(Host, DependedSoftware1, DependedSoftware3) :-
  dependsOn(Host, DependedSoftware1, DependedSoftware2),
  dependsOn(Host, DependedSoftware2, DependedSoftware3)),
 rule_desc('Transitive dependencies', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  hasAccount(User, Host, Account)),
 rule_desc('principal Prin can execute arbitrary code with privilege UserPriv on machine Host.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account) :-
  principalCompromised(User2, User1),
  hasAccount(User2, Host, Account),
  canAccessHost(User1, Host)),
 rule_desc('When a principal is compromised, any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  malicious(User),
  execCode(User, Host, Account2),
  vulExists(Host, _VulID, Software, localExploit, privEscalation),
  setuidProgram(Host, Software, Account)),
 rule_desc('Local exploit', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(Attacker, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program (remote privilege escalation)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  setuidProgram(Host, Software, _Account),
  fileOwner(Host, Path, Account),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local privilege escalation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  vulExists(Host, _VulID, Software, remoteExploit, privilegeEscalation),
  clientProgram(Host, Software),
  incompetent(User),
  hasAccount(User, Host, Account)),
 rule_desc('Remote exploit for a client program (exploit remote client)', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, root) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path)),
 rule_desc('Trojan horse installation', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  not setuidProgram(Host, Path, _Account),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, OwnerAccount) :-
  malicious(Attacker),
  accessFile(Attacker, Host, write, Path),
  setuidProgram(Host, Path, _Account),
  fileOwner(Host, Path, OwnerAccount),
  localFileProtection(Host, Account, exec, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, Account) :-
  principalCompromised(Victim, Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Attacker, Host)),
 rule_desc('Once the credential of a principal is compromised, an attacker can compromise accounts of the principal on any machine the attacker has access to.', 1.0)).

interaction_rule(
 (execCode(User1, Host, Account):-
  malicious(User1),
  inCompetent(User2),
  dataInject(User1, Host, _Software, Account),
  localAccess(User2, Host, Account)),
 rule_desc('Incompetent user execute malicious code included in injected data', 1.0)).

interaction_rule(
 (execCode(User, DstHost, Account):-
  malicious(User),
  vulHost(DstHost, VulID, Prot, adjacent, completePrivEsc),
  l2Access(User, SrcHost, DstHost, Prot, Zone, Type)),
 rule_desc('Exploit vulnerability from adjecent', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, VulID, Software, remote, privEscalation),
  networkService(Host, Software, Protocol, Port, Account),
  netAccess(_User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a service program', 1.0)).

interaction_rule(
 (execCode(_User, Vm_id, Account) :-
  vulEixsts(Vm_id, stealthyBridge_id, _Software, _ExploitRange, privEscalation),
  netAccess(_User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('remoteExploit of a stealthy bridge', 1.0)).

interaction_rule(
 (execCode(_User, Vm_2, _Account) :-
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('A stealthy bridge could lead to privilege escalation on victim machine.', 1.0)).

interaction_rule(
 (execCode(_User, Host, root) :-
  execArbitraryCode(Host, _Account)),
 rule_desc('Executing an arbitrary code to escalate its privilages', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  principalCompromised(Victim, _Attacker),
  hasAccount(Victim, Host, Account),
  canAccessHost(Victim, Host)),
 rule_desc('When a principal is compromised any machine he has an account on will also be compromised', 1.0)).

interaction_rule(
 (execCode(Victim, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteClient, privEscalation),
  hasAccount(Victim, Host, Account),
  accessMaliciousInput(Host, Victim, Software)),
 rule_desc('Remote exploit for a client program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  networkService(Host, Software, Protocol, Port, _Account),
  netAccess(User, _SrcHost, Host, Protocol, Port)),
 rule_desc('Remote exploit of a server program', 1.0)).

interaction_rule(
 (execCode(User, Host, Account) :-
  vulExists(Host, _VulID, Software, remoteExploit, privEscalation),
  installed(Host, Software),
  netAccess(User, _SrcHost, Host, _Protocol, _Port)),
 rule_desc('Remote exploit of host', 1.0)).

interaction_rule(
 (execCode(_User, Host, Account) :-
  vulExists(Host, _VulID, Software, _ExploitRange, privEscalation),
  localService(Host, Software, Account),
  usbMounted(Host, USB_Drive),
  malwareLocated(USB_Drive)),
 rule_desc('Exploit via Infected USB', 1.0)).

interaction_rule(
 (execCode(Attacker, TargetHost, _Account) :-
  canWrite(Attacker, Resource),
  trusts(TargetHost, Resource)),
 rule_desc('If a principal Target trusts a resource(Type, Name, Dacl) and if a principal Attacker can write to this resource, then the adversary Attacker can launch a privilege escalation to Target.', 1.0)).

interaction_rule(
 (execCode(Attacker, Host, SoftwareAccount) :-
  vulExists(Host, _VulID, Software, localExploit, privilegeEscalation),
  privilegedProgram(Host, Software, SoftwareAccount),
  execCode(Attacker, Host, _SomeAccount)),
 rule_desc('Local attack against a privileged program', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessData(User, Permission, Data) :-
  dataBind(Data, Host, Path),
  accessFile(User, Host, Permission, Path)),
 rule_desc('All possible data accesses that can result from multistage, multi-host attacks', 1.0)).

interaction_rule(
 (policyViolation(User, Permission, Data) :-
  accessData(User, Permission, Data),
  not allow(User, Permission, Data)),
 rule_desc('Policy checking', 1.0)).

interaction_rule(
 (vulProperty(VulID, ExploitRange, ExploitConsequence) :-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port),
  advances(Host1, Host2)),
 rule_desc('advances predicate should return true only when the transition H1 -> H2 is useful.', 1.0)).

interaction_rule(
 (execCode(Host, root) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, Action),
  canLeadToPrivEscalation(Action)),
 rule_desc('', 1.0)).

interaction_rule(
 (execCode(Software, Processor) :-
  process(Software, Processor, _Os),
  execCode(Software2, Processor2),
  memoryMap(Processor, Processor2, InitRange, EndRange),
  accessMemory(Software2, InitRange, EndRange)),
 rule_desc('An attacker can gain the ability to execute arbitrary code on a Process if he can do so on Process2, the two processors are connected by memory mapping, and Process2 can access the mapped memory range.', 1.0)).

interaction_rule(
 (softwareCompromised(Software) :-
  attackerLocatedSW(Software)),
 rule_desc('An internal component is compromised if the attacker controls that particular component.', 1.0)).

interaction_rule(
 (softwareCompromised(Software) :-
  canInvoke(Software1, Software, Method),
  softwareCompromised(Software1),
  compVulnExists(Software, Method, _VulId)),
 rule_desc('An internal component is compromised if there exists a transitive relationship so that an already compromised component comp1 can invoke a vulnerable method of that component.
For instance the frontend component in the running example can exploit an authentication bypass vulnerability in the login method to compromise the account manager, which then enables compromising the database manager via the executeQuery method.', 1.0)).

interaction_rule(
 (softwareCompromised(Software) :-
  attackerLocatedSW(Software)),
 rule_desc('An internal component is compromised if the attacker controls that particular component.', 1.0)).

interaction_rule(
 (softwareCompromised(Software) :-
  canInvoke(Software1, Software, Method),
  softwareCompromised(Software1),
  compVulnExists(Software, Method, _VulId)),
 rule_desc('An internal component is compromised if there exists a transitive relationship so that an already compromised component comp1 can invoke a vulnerable method of that component.
For instance the frontend component in the running example can exploit an authentication bypass vulnerability in the login method to compromise the account manager, which then enables compromising the database manager via the executeQuery method.', 1.0)).

interaction_rule(
 (exCompromised(ExternalSoftware) :-
  exInterface(ExternalSoftware),
  exVulnerability(ExternalSoftware, VulnType)),
 rule_desc('An external component can be compromised if it exports an external interface that contains a vulnerability.', 1.0)).

interaction_rule(
 (exCompromised(ExternalSoftware) :-
  softwareCompromised (Software),
  exVulnerability(ExternalSoftware, VulnType ),
  canCauseexVulnerability(Software, VulnType, Method),
  exInvocation(ExternalSoftware, Software, Method)),
 rule_desc('An external component can be compromised if it can be invoked from a compromised internal component in a method that can cause an external vulnerability, and that vulnerability is present in the external component.', 1.0)).

interaction_rule(
 (exCompromised(ExternalSoftware) :-
  exInterface(ExternalSoftware),
  exVulnerability(ExternalSoftware, VulnType)),
 rule_desc('An external component can be compromised if it exports an external interface that contains a vulnerability.', 1.0)).

interaction_rule(
 (exCompromised(ExternalSoftware) :-
  softwareCompromised (Software),
  exVulnerability(ExternalSoftware, VulnType ),
  canCauseexVulnerability(Software, VulnType, Method),
  exInvocation(ExternalSoftware, Software, Method)),
 rule_desc('An external component can be compromised if it can be invoked from a compromised internal component in a method that can cause an external vulnerability, and that vulnerability is present in the external component.', 1.0)).

interaction_rule(
 (canInjectCommand(ExternalSoftware) :-
  exCompromised(ExternalSoftware),
  exVulnerability(ExternalSoftware, cwe89),
  vulnType(cwe89)),
 rule_desc('Command injection attack, enabled by external components.', 1.0)).

interaction_rule(
 (canInjectCommand(Software) :-
  softwareCompromised(Software),
  compVulnExists(Software, _Method, cwe89),
  vulnType(cwe89)),
 rule_desc('Command injection attack, enabled by internal components.', 1.0)).

interaction_rule(
 (canInjectCommand(ExternalSoftware) :-
  exCompromised(ExternalSoftware),
  exVulnerability(ExternalSoftware, cwe89),
  vulnType(cwe89)),
 rule_desc('Command injection attack, enabled by external components.', 1.0)).

interaction_rule(
 (canInjectCommand(Software) :-
  softwareCompromised(Software),
  compVulnExists(Software, _Method, cwe89),
  vulnType(cwe89)),
 rule_desc('Command injection attack, enabled by internal components.', 1.0)).

interaction_rule(
 (canPrivEsc(Software) :-
  canInjectCommand(Software),
  badConfiguration(Software)),
 rule_desc('Command injection and privilege escalation', 1.0)).

interaction_rule(
 (canDeleteDoc(Software ) :-
  canSpoofUsr(Software),
  canLeakDoc(Software)),
 rule_desc('Document deletion', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based whitebox evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, score, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox score based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Boundary based blackbox decision based evasion attacks', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  surrogateDataAccess(User, PiplineID, ModelID, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes reference data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based blackbox decision based evasion attacks that utilizes training data', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID,  ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write,limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient based targeted whitebox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (evasionAttack(User, PiplineID, ModelID, tampering) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID,ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability based targeted blackbox poisoning attack against feature selection', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient-based, indiscriminate, white-box poisoning attack', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, _VulType),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability-based, indiscriminate, black-box poisoning attack', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient-based, indiscriminate, white-box poisoning attacka against feature selection', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, _VulType),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(Principal, PiplineID, ModelID, full)),
 rule_desc('Transferability-based, indiscriminate, black-box poisoning attack against feature selection', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient-based, indiscriminate, white-box poisoning attack', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, _VulType),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability-based, indiscriminate, black-box poisoning attack', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient-based, indiscriminate, white-box poisoning attacka against feature selection', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, _VulType),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(Principal, PiplineID, ModelID, full)),
 rule_desc('Transferability-based, indiscriminate, black-box poisoning attack against feature selection', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient-based, indiscriminate, white-box poisoning attack', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, _VulType),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability-based, indiscriminate, black-box poisoning attack', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient-based, indiscriminate, white-box poisoning attacka against feature selection', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, _VulType),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(Principal, PiplineID, ModelID, full)),
 rule_desc('Transferability-based, indiscriminate, black-box poisoning attack against feature selection', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient-based, indiscriminate, white-box poisoning attack', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, _VulType),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Transferability-based, indiscriminate, black-box poisoning attack', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, evasionAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Gradient-based, indiscriminate, white-box poisoning attacka against feature selection', 1.0)).

interaction_rule(
 (mlModelCorruptionAttack(User, PiplineID, ModelID, tampering_dos) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, _VulType),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, write, limited),
  surrogateDataAccess(User, PiplineID, ModelID, full),
  queryAccess(User, PiplineID, ModelID, decision, limited),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, full),
  dataPropertiesKnowledge(User, PiplineID, ModelID, full),
  taskKnowledge(Principal, PiplineID, ModelID, full)),
 rule_desc('Transferability-based, indiscriminate, black-box poisoning attack against feature selection', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Shadow training-based, black-box membership inference attacks', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, full),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, full),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, score, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  hyperparametersKnowledge(User, PiplineID, ModelID, full),
  algorithmKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Gradient-based, white-box membership inference attacks', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Membership inference attacks exploiting attackers access', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Shadow training-based, black-box membership inference attacks', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, full),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, full),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, score, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  hyperparametersKnowledge(User, PiplineID, ModelID, full),
  algorithmKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Gradient-based, white-box membership inference attacks', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Membership inference attacks exploiting attackers access', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, decision, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Shadow training-based, black-box membership inference attacks', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelRetrainedContinuously(PiplineID, ModelID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, full),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, full),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, write, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, limited),
  queryAccess(User, PiplineID, ModelID, score, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  hyperparametersKnowledge(User, PiplineID, ModelID, full),
  algorithmKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, full)),
 rule_desc('Gradient-based, white-box membership inference attacks', 1.0)).

interaction_rule(
 (membershipInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, membershipInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Membership inference attacks exploiting attackers access', 1.0)).

interaction_rule(
 (dataPropertyInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataPropertyInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID ,_AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Shadow training-based property inference attacks', 1.0)).

interaction_rule(
 (dataPropertyInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataPropertyInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Property inference attacks exploiting attackers access', 1.0)).

interaction_rule(
 (dataPropertyInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataPropertyInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID ,_AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Shadow training-based property inference attacks', 1.0)).

interaction_rule(
 (dataPropertyInferenceAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataPropertyInferenceAttackVulnerability),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Property inference attacks exploiting attackers access', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, limited),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, limited),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Maximum a posteriori-based, gray-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, limited),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, limited),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Gradient optimization-based, gray-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  rawDataAccess(User, PiplineID,ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Black-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  rawDataAccess(Principal, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Data theft due to data breach', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, limited),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, limited),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Maximum a posteriori-based, gray-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, limited),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, limited),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Gradient optimization-based, gray-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  rawDataAccess(User, PiplineID,ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Black-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  rawDataAccess(Principal, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Data theft due to data breach', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, limited),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, limited),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Maximum a posteriori-based, gray-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, limited),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, limited),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Gradient optimization-based, gray-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  rawDataAccess(User, PiplineID,ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Black-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  rawDataAccess(Principal, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Data theft due to data breach', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, limited),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, limited),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Maximum a posteriori-based, gray-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, limited),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, _AccessType, limited),
  rawDataAccess(User, PiplineID, ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  modelKnowledge(User, PiplineID, ModelID, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Gradient optimization-based, gray-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, dataReconstructionAttackVulnerability),
  rawDataAccess(User, PiplineID,ModelID, RawDataID, _AccessType, limited),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, limited),
  queryAccess(User, PiplineID, ModelID, _AccessType, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Black-box data reconstruction attacks', 1.0)).

interaction_rule(
 (dataReconstructionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  rawDataAccess(Principal, PiplineID, ModelID, RawDataID, _AccessType, full),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, _AccessType, full),
  labeledDataAccess(User, PiplineID, ModelID, LabeledDataID, _AccessType, full)),
 rule_desc('Data theft due to data breach', 1.0)).

interaction_rule(
 (modelExtractionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, modelExtractionAttackVulnerability),
  queryAccess(User, PiplineID,ModelID, _AccessType, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Query-based,black-box model extraction attacks', 1.0)).

interaction_rule(
 (modelExtractionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, modelExtractionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, full)),
 rule_desc('Attackers access-based model extraction attack', 1.0)).

interaction_rule(
 (modelExtractionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, modelExtractionAttackVulnerability),
  queryAccess(User, PiplineID,ModelID, _AccessType, full),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, partial),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, partial),
  taskKnowledge(User, PiplineID, ModelID, partial)),
 rule_desc('Query-based,black-box model extraction attacks', 1.0)).

interaction_rule(
 (modelExtractionAttack(User, PiplineID, ModelID, informationDisclosure) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, modelExtractionAttackVulnerability),
  modelAccess(User, PiplineID, ModelID, _AccessType, full)),
 rule_desc('Attackers access-based model extraction attack', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  completeKnowledge(User, PiplineID, ModelID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating the training data', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  externalSourceLabeling(TrainingDataID, LabelingServiceId, false),
  hasAccessToLabelingService(User, LabelingServiceId),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating unvalidated external labeling process', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  externalSourceLabeling(TrainingDataID, LabelingServiceId, true),
  hasAccessToLabelingService(User, LabelingServiceId),
  knowDataValidationMethod(User, LabelingServiceId),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating validated external labeling process', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  completeKnowledge(User, PiplineID, ModelID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating the training data', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  externalSourceLabeling(TrainingDataID, LabelingServiceId, false),
  hasAccessToLabelingService(User, LabelingServiceId),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating unvalidated external labeling process', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  externalSourceLabeling(TrainingDataID, LabelingServiceId, true),
  hasAccessToLabelingService(User, LabelingServiceId),
  knowDataValidationMethod(User, LabelingServiceId),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating validated external labeling process', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  completeKnowledge(User, PiplineID, ModelID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating the training data', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  externalSourceLabeling(TrainingDataID, LabelingServiceId, false),
  hasAccessToLabelingService(User, LabelingServiceId),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating unvalidated external labeling process', 1.0)).

interaction_rule(
 (labelManipulationAttack(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  vulModel(PiplineID, AlgorithmID, ModelID, ModelHost, labelManipulationAttackVulnerability),
  modelRetrainedContinuously(PiplineID, ModelID),
  externalSourceLabeling(TrainingDataID, LabelingServiceId, true),
  hasAccessToLabelingService(User, LabelingServiceId),
  knowDataValidationMethod(User, LabelingServiceId),
  completeKnowledge(User, PiplineID, ModelID)),
 rule_desc('Attacker can execute label manipulation attack by manipulating validated external labeling process', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  trainingData(DataID, TrainingDataHost),
  accessFile(User, TrainingDataHost, write, TrainingDataID)),
 rule_desc('Manipulate training data through direct access to the training set', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  trainingData(TrainingDataID, TrainingDataHost),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID, JobHost, InputDataID, InputDataHost, TrainingDataID, TrainingDataHost)),
 rule_desc('Manipulate training data through access to feature store', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID1, JobHost1, InputDataID, InputDataHost, TransformedDataID, TransformedDataHost),
  dataTransformationJob(JobID2, JobHost2, TransformedDataID, TransformedDataHost, TrainingDataID, TrainDataHost)),
 rule_desc('Manipulate training data through access to raw data', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  trainingData(DataID, TrainingDataHost),
  accessFile(User, TrainingDataHost, write, TrainingDataID)),
 rule_desc('Manipulate training data through direct access to the training set', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  trainingData(TrainingDataID, TrainingDataHost),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID, JobHost, InputDataID, InputDataHost, TrainingDataID, TrainingDataHost)),
 rule_desc('Manipulate training data through access to feature store', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID1, JobHost1, InputDataID, InputDataHost, TransformedDataID, TransformedDataHost),
  dataTransformationJob(JobID2, JobHost2, TransformedDataID, TransformedDataHost, TrainingDataID, TrainDataHost)),
 rule_desc('Manipulate training data through access to raw data', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  trainingData(DataID, TrainingDataHost),
  accessFile(User, TrainingDataHost, write, TrainingDataID)),
 rule_desc('Manipulate training data through direct access to the training set', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  trainingData(TrainingDataID, TrainingDataHost),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID, JobHost, InputDataID, InputDataHost, TrainingDataID, TrainingDataHost)),
 rule_desc('Manipulate training data through access to feature store', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID1, JobHost1, InputDataID, InputDataHost, TransformedDataID, TransformedDataHost),
  dataTransformationJob(JobID2, JobHost2, TransformedDataID, TransformedDataHost, TrainingDataID, TrainDataHost)),
 rule_desc('Manipulate training data through access to raw data', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (modelAcces5(User, PiplineID, ModelID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, read, ModelID)),
 rule_desc('has read access to model', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeAccess(User, PiplineID, ModelID, DataAccessPrivilege) :-
  modelAccess(User, PiplineID, ModelID, DataAccessPrivilege, AccessLevel),
  predictionsAccess(User, PiplineID, ModelID, PredictionsDataID, DataAccessPrivilege, AccessLevel),
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel),
  validationDataAccess(User, PiplineID, ModelID, ValidationDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has complete access to the pipeline', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
 malicious(User),
 model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
 publicModel(ModelID)),
 rule_desc('Hyper parameters knowledge using public model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
 malicious(User),
 model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
 publicModel(ModelID)),
 rule_desc('Hyper parameters knowledge using public model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Algorithm knowledge using public model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, read, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Algorithm knowledge using public model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, read, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (createSurrogateModel(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Create surrogate model by quering the target model', 1.0)).

interaction_rule(
 (createSurrogateModel(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel)),
 rule_desc('Creates surrogate model based on model training data knowledge', 1.0)).

interaction_rule(
 (createSurrogateModel(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Create surrogate model by quering the target model', 1.0)).

interaction_rule(
 (createSurrogateModel(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel)),
 rule_desc('Creates surrogate model based on model training data knowledge', 1.0)).

interaction_rule(
 (vulProperty(VulID, ExploitRange, ExploitConsequence) :-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (dependsOn(Host, DependedSoftware1, DependedSoftware3) :-
  dependsOn(Host, DependedSoftware1, DependedSoftware2),
  dependsOn(Host, DependedSoftware2, DependedSoftware3)),
 rule_desc('Transitive dependencies', 1.0)).

interaction_rule(
 (imageVulExists(VMI_id, stealthyBridge_id, _Software, remoteExploit, privEscalation):-
  isThirdPartyImage(VMI_id)),
 rule_desc('A third party VMI could contain a stealthy bridge.', 1.0)).

interaction_rule(
 (vulProperty(VulID, ExploitRange, ExploitConsequence) :-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulProperty(VulID, ExploitRange, ExploitConsequence) :-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (dependsOn(Host, DependedSoftware1, DependedSoftware3) :-
  dependsOn(Host, DependedSoftware1, DependedSoftware2),
  dependsOn(Host, DependedSoftware2, DependedSoftware3)),
 rule_desc('Transitive dependencies', 1.0)).

interaction_rule(
 (imageVulExists(VMI_id, stealthyBridge_id, _Software, remoteExploit, privEscalation):-
  isThirdPartyImage(VMI_id)),
 rule_desc('A third party VMI could contain a stealthy bridge.', 1.0)).

interaction_rule(
 (vulProperty(VulID, ExploitRange, ExploitConsequence) :-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulProperty(VulID, ExploitRange, ExploitConsequence) :-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (dependsOn(Host, DependedSoftware1, DependedSoftware3) :-
  dependsOn(Host, DependedSoftware1, DependedSoftware2),
  dependsOn(Host, DependedSoftware2, DependedSoftware3)),
 rule_desc('Transitive dependencies', 1.0)).

interaction_rule(
 (imageVulExists(VMI_id, stealthyBridge_id, _Software, remoteExploit, privEscalation):-
  isThirdPartyImage(VMI_id)),
 rule_desc('A third party VMI could contain a stealthy bridge.', 1.0)).

interaction_rule(
 (vulProperty(VulID, ExploitRange, ExploitConsequence) :-
  bugHyp(Host, Software, ExploitRange, ExploitConsequence)),
 rule_desc('', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path) :-
  execCode(User, Host, Account),
  localFileProtection(Host, Account, Permission, Path)),
 rule_desc('principal Prin can Access the files specified by Path on machine Host. execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('principal Prin can access files on a NFS server if the files on the server are mounted at a client and he can access the files on the client side', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ClientPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, read),
  accessFile(User, ServerHost, Permission, ServerPath)),
 rule_desc('principal Prin can access files on a NFS client if the files on the server are mounted at the client and he can access the files on the server side', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, _RootSquash, _IsSecure)),
 rule_desc('NFS shell', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, insecure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, Path) :-
  malicious(User),
  netAccess(User, ClientHost, ServerHost, rpc, 100003),
  execCode(User, ClientHost, root),
  nfsExportInfo(ServerHost, Path, ClientHost, Permission, RootSquash, secure),
  nfsUserMap(ClientAccount, ServerAccount, RootSquash),
  localFileProtection(ServerHost, ServerAccount, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (accessFile(User, ClientHost, Permission, ServerPath) :-
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  accessFile(User, ServerHost, Permission, ClientPath)),
 rule_desc('When a principal accesses files in a portion that is exported to a client machine, he is also, in some sense, accessing files on a client that mounted that portion.', 1.0)).

interaction_rule(
 (accessFile(User, DstHost, read ,_path):-
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  aclH_p(DstHost, NetServiceAccount, SrcHost, Prot, Port),
  vulHost(DstHost, _vulID, Software, remoteExploit, completeDataTheft),
  malicious(User),
  netAccess(User, SrcHost, DstHost, Prot, Port)),
 rule_desc('Vulnerability is exploited via network', 1.0)).

interaction_rule(
 (accessFile(User, Host, Permission, Path):-
  localFileProtection(Host, Account, Permission, Path),
  localAccess(User, Host, Account)),
 rule_desc('Principal can access data at Path on Host with Access privilege.', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, Path) :-
  execCode(_User, Host, Account),
  canAccessFile(Host, Account, Path)),
 rule_desc('execCode implies file access', 1.0)).

interaction_rule(
 (accessFile(_User, Host, _Permission, FileName) :-
  execCode(_User, Host, Account),
  dataTransitsThrough(Host, FileName)),
 rule_desc('Access to files going through compromised host', 1.0)).

interaction_rule(
 (accessFile(User, ServerHost, Permission, ServerPath) :-
  nfsExportInfo(ServerHost, Path, ClientHost, Permission),
  nfsMounted(ClientHost, ClientPath, ServerHost, ServerPath, Permission),
  netAccess(User, ClientHost, ServerHost, rpc, 100003).
  accessFile(User, ClientHost, Permission, ClientPath)),
 rule_desc('If files are mounted on the client side using the NFS protocol, and if the adversary can access files on the client side, then the adversary can access the files on the server side.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  fileOwner(Host, Path, Account),
  ownerAccessible(Host, Permission, Path)),
 rule_desc('The User on machine Host can have the specified Access to the file Path.', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  inGroup(Account, GroupAccount),
  fileGroupOwner(Host, Path, GroupAccount),
  groupAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localFileProtection(Host, Account, Permission, Path) :-
  worldAccessible(Host, Permission, Path)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (ownerAccessible(Host, read, Path) :-
  fileAttr(Host, Path, r,_,_,_,_,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by its owner', 1.0)).

interaction_rule(
 (ownerAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,w,_,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,x,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,r,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by group', 1.0)).

interaction_rule(
 (groupAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,w,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,x,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,r,_,_)),
 rule_desc('The file Path on Machine Host has Access by anyone', 1.0)).

interaction_rule(
 (worldAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,w,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,_,x)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, read, Path) :-
  fileAttr(Host, Path, r,_,_,_,_,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by its owner', 1.0)).

interaction_rule(
 (ownerAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,w,_,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,x,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,r,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by group', 1.0)).

interaction_rule(
 (groupAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,w,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,x,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,r,_,_)),
 rule_desc('The file Path on Machine Host has Access by anyone', 1.0)).

interaction_rule(
 (worldAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,w,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,_,x)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, read, Path) :-
  fileAttr(Host, Path, r,_,_,_,_,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by its owner', 1.0)).

interaction_rule(
 (ownerAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,w,_,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (ownerAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,x,_,_,_,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,r,_,_,_,_,_)),
 rule_desc('The file Path on Machine Host has Access by group', 1.0)).

interaction_rule(
 (groupAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,w,_,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (groupAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,x,_,_,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, read, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,r,_,_)),
 rule_desc('The file Path on Machine Host has Access by anyone', 1.0)).

interaction_rule(
 (worldAccessible(Host, write, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,w,_)),
 rule_desc('', 1.0)).

interaction_rule(
 (worldAccessible(Host, exec, Path) :-
  fileAttr(Host, Path, _,_,_,_,_,_,_,_,_,x)),
 rule_desc('', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Attacker, Host, root),
  malicious(Attacker)),
 rule_desc('Victims credential is compromised by Attacker', 1.0)).

interaction_rule(
 (principalCompromised(Victim, Attacker) :-
  incompetent(Victim),
  malicious(Attacker)),
 rule_desc('Incompetent user', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  // The victim has a user account on the remote host
  hasAccount(Victim, RemoteHost, Account),
  // nrlolsr is being used
  networkService(Host, nrlolsr, olsr, _Port, _Account),
 // nrlolsr is misconfigured allowing traffic hijacking
  vulExists(Host, nrlolsrVul, nrlolsr, remoteExploit, nrlolsrHijack),
  // The User has an account on a login service on the remote host
  logInService(RemoteHost, Protocol, Port),
  // There is an active connection from the host to the remote machine
  flowExists(Host, RemoteHost, Protocol, Port, Account)),
 rule_desc('The principal is compromised if it has an account, an active connection to a login service on a node, and OLSR is misconfigured. Route hijacking does not require the attacker to be located in the victims subnet.', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, _Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (principalCompromised(Victim, _Attacker) :-
  hasAccount(Victim, Host, Account),
  execCode(Victim, Host, root)),
 rule_desc('Password sniffing', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsUserMap(Account, Account, root_squash) :-
  nonvar(Account),
  non_root_user(Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (nfsMounted(ClientHost, _ClientPath, _ServerHost, _ServerPath, _Permission) :-
  execCode(User, ClientHost, root)),
 rule_desc('if an administrative account is compromised on the client side, then the attacker can mount any files.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (dataInject(User, Host, _Software, Account):-
  localAccess(User, Host, Account)),
 rule_desc('Principal can inject any data from local', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  execCode(User, Host, _SomeAccount)),
 rule_desc('To use the stolen credential to compromise another host, an attacker needs some access to the machine. Either he can get into the machine as another user and then execute the su command, or he is able to access the login service (such as sshd) on the host.', 1.0)).

interaction_rule(
 (canAccessHost(User, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(User, _AttackSrc, Host, Protocol, Port)),
 rule_desc('Access a host through a log in service', 1.0)).

interaction_rule(
 (canAccessHost(_User, Vm_2) :-
  logInService(Vm_2, Protocol, Port),
  stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id)),
 rule_desc('Access a host through a log-in service by obtaining authentication information through stealthy bridges.', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  execCode(Attacker, Host, _Account)),
 rule_desc('Access a host through executing code on the machine', 1.0)).

interaction_rule(
 (canAccessHost(Attacker, Host) :-
  logInService(Host, Protocol, Port),
  netAccess(Attacker, _SrcHost, Host, Protocol, Port)),
 rule_desc('Access a host through a log-in service', 1.0)).

interaction_rule(
 (hasAccount(User, Host2, Account):-
  accessFile(User, Host1, read, Path),
  dataBind(Credential, Host1, Path),
  isCredential(Credential, Host2, Account),
  malicious(User)),
 rule_desc('Principal has the credential of account User2 on Host2.', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (logInService(Host, Protocol, Port) :-
  networkService(Host, sshd, Protocol, Port, _Account)),
 rule_desc('ssh is a log in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (logInService(Host, Protocol, Port) :-
  networkService(Host, sshd, Protocol, Port, _Account)),
 rule_desc('ssh is a log in service', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (logInService(Host, Protocol, Port) :-
  networkService(Host, sshd, Protocol, Port, _Account)),
 rule_desc('ssh is a log in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (logInService(Host, Protocol, Port) :-
  networkService(Host, sshd, Protocol, Port, _Account)),
 rule_desc('ssh is a log in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (logInService(Host, Protocol, Port) :-
  networkService(Host, sshd, Protocol, Port, _Account)),
 rule_desc('ssh is a log in service', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (logInService(Host, Protocol, Port) :-
  networkService(Host, sshd, Protocol, Port, _Account)),
 rule_desc('ssh is a log in service', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Protocol, Port) :-
  execCode(User, SrcHost, _Account),
  hacl(SrcHost, DstHost, Protocol, Port)),
 rule_desc('principal Prin can send packets from machine Src to Port on machine Dst through Protocol, multi-hop', 1.0)).

interaction_rule(
 (netAccess(User, Zone, Host, Protocol, Port) :-
  located(User, Zone),
  hacl(Zone, Host, Protocol, Port)),
 rule_desc('Direct net access', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, SrcAccount),
  aclH(SrcHost, SrcAccount, DstHost, Prot, Port),
  aclNW(SrcHost, DstHost, Prot, Port)),
 rule_desc('Principal can access from neighber', 1.0)).

interaction_rule(
 (netAccess(User, SrcHost, DstHost, Prot, Port):-
  localAccess(User, SrcHost, _SrcAccount),
  aclNW(SrcHost, DstHost, Prot, Port) ),
 rule_desc('Principal can access DstHost from SrcHost using Protocol and Port.', 1.0)).

interaction_rule(
 (netAccess(_User, _SrcHost, Host2, _Protocol, _Port) :-
  gateway(Host1),
  advances(Host1, Host2),
  netAccess(_User, _SrcHost, Host1, _Protocol, _Port),
  hacl(Host1, Host2, _Protocol, _Port)),
 rule_desc('The execCode derivation rule requires that an attacker has network access (the canAccessHost rule) to the victim machine. This overloaded definition enables the derivation of canAccessHost.', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  firstHop(Host, TgtHost)),
 rule_desc('Network access - first hop', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  sameSwitch(Host, TgtHost)),
 rule_desc('Network access via same switch', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, Port) :-
  multiHop(Host, TgtHost)),
 rule_desc('Network multiple switches', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  firstHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  sameSwitch(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host, TgtHost, _Protocol, _Port) :-
  notSame(Host, TgtHost),
  notSame(Host, Intermediary),
  notSame(TgtHost, Intermediary),
  multiHop(Host, Intermediary),
  pivotPoint(Intermediary, TgtHost)),
 rule_desc('Network access via pivot point', 1.0)).

interaction_rule(
 (netAccess(_User, Host1, Host2, Protocol, Port) :-
  execCode(_User, Host1, _Account),
  reachable(Host1, Host2, Protocol, Port)),
 rule_desc('If an attacker can execute arbitrary code on machine H1 at some permission level, and machine H1 can reach machine H2 through Protocol and Port, then the attacker can access machine H2 through Protocol and Port. In this way, privileges on H1 can enable an attacker to access H2.', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (l2Access(User, SrcHost, DstHost, Prot, Zone, Type):-
  l2Connection(SrcHost, DstHost, Zone, Prot, Type),
  localAccess(User, SrcHost, _Account)),
 rule_desc('Host access via shared medium', 1.0)).

interaction_rule(
 (relay(MITMHost, SrcHost, DstHost, Prot, Port):-
  mitmE2E(_User, SrcHost, DstHost, MITMHost, Prot, Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(ImHost, SrcHost, DstHost, Prot, Port):-
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flonwname, Prot, Port),
  relay(ImHost, Flowname)),
 rule_desc('relay2 to relay5', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (relay(MITMHost, SrcHost, DstHost, Prot, Port):-
  mitmE2E(_User, SrcHost, DstHost, MITMHost, Prot, Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(ImHost, SrcHost, DstHost, Prot, Port):-
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flonwname, Prot, Port),
  relay(ImHost, Flowname)),
 rule_desc('relay2 to relay5', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (relay(MITMHost, SrcHost, DstHost, Prot, Port):-
  mitmE2E(_User, SrcHost, DstHost, MITMHost, Prot, Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(ImHost, SrcHost, DstHost, Prot, Port):-
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flonwname, Prot, Port),
  relay(ImHost, Flowname)),
 rule_desc('relay2 to relay5', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (relay(MITMHost, SrcHost, DstHost, Prot, Port):-
  mitmE2E(_User, SrcHost, DstHost, MITMHost, Prot, Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(ImHost, SrcHost, DstHost, Prot, Port):-
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flonwname, Prot, Port),
  relay(ImHost, Flowname)),
 rule_desc('relay2 to relay5', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (relay(MITMHost, SrcHost, DstHost, Prot, Port):-
  mitmE2E(_User, SrcHost, DstHost, MITMHost, Prot, Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (relay(ImHost, SrcHost, DstHost, Prot, Port):-
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flonwname, Prot, Port),
  relay(ImHost, Flowname)),
 rule_desc('relay2 to relay5', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessLinkFlow(User, Host, AP, Protocol, read):-
  malicious(User),
  localAccess(User, AttackerHost, admin),
  located(AttackerHost, WirelessRange, physical),
  flowBind(Flowname, Protocol, Port),
  isCredential(Flowname, DstZone, Account),
  vulLinkProtocol(WirelessRange, VulID, Protocol, adjacent, keyReinstallation),
  isAP(AP, WirelessRange, DstZone, Protocol, secured),
  located(Host, WirelessRange, physical)),
 rule_desc('WPA2 Key Reinstallation. (1) The attacker becomes a MITM between the host and the access point (e.g., by channel-based MITM technique); and (2) the attacker prevents the 4th handshake message from reaching the access point, which causes the retransmission of the 3rd message.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessLinkFlow(User, Host, AP, Protocol, read):-
  malicious(User),
  localAccess(User, AttackerHost, admin),
  located(AttackerHost, WirelessRange, physical),
  flowBind(Flowname, Protocol, Port),
  isCredential(Flowname, DstZone, Account),
  vulLinkProtocol(WirelessRange, VulID, Protocol, adjacent, keyReinstallation),
  isAP(AP, WirelessRange, DstZone, Protocol, secured),
  located(Host, WirelessRange, physical)),
 rule_desc('WPA2 Key Reinstallation. (1) The attacker becomes a MITM between the host and the access point (e.g., by channel-based MITM technique); and (2) the attacker prevents the 4th handshake message from reaching the access point, which causes the retransmission of the 3rd message.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessDataFlow(User, FlowName, read) :-
  crackAPEncKey(User, _Host, AP),
  relay(AP, FlowName),
  dataFlow(Host, _DstHost, FlowName, _Direction),
  flowBind(FlowName, Prot, Port),
  vulE2EProtocol(Host, _NameResolver, VulID, Prot, Port, remoteExploit, eavesdropping),
  isAP(AP, WirelessRange, DstZone, WirelessProt, secured),
  located(AttackerHost, WirelessRange, physical),
  localAccess(User, AttackerHost, admin)),
 rule_desc('By cracking the encryption key, the attacker can eavesdrop on all of the traffic broadcasted by the compromised access point.', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, AP, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, _DstHost, Flowname, _Direction),
  relay(AP, Flowname)),
 rule_desc('Viewing traffic by capturing wireless signals via relay - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  accessDataFlow(User, Flowname, view),
  vulLinkProtocol(SrcHost, DstHost, VulID, WirelessProt, Range, eavesdropping),
  dataFlow(SrcHost, DstHost, Flowname, _Direction),
  flowBind(Flowname, WirelessProt, _Port)),
 rule_desc('Reading specific wireless link layer communication', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, view):-
  l2Connection(SrcHost, DstHost, WirelessRange, Prot, wireless),
  located(SideHost, WirelessRange, physical),
  localAccess(User, SideHost, admin),
  dataFlow(SrcHost, DstHost, Flowname, Direction)),
 rule_desc('Viewing traffic by capturing wireless signals - not necessarily plaintext', 1.0)).

interaction_rule(
 (accessDataFlow(User, Flowname, read):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port),
  located(SideHost, BluetoothRange, physical),
  localAccess(User, SideHost, admin)),
 rule_desc('Reading bluetooth data flow between two hosts using cracked PIN code. The consequence of this attack is that the attacker acquires the capability to decipher the communication between SrcHost and DstHost.', 1.0)).

interaction_rule(
 (accessLinkFlow(User, Host, AP, Protocol, read):-
  malicious(User),
  localAccess(User, AttackerHost, admin),
  located(AttackerHost, WirelessRange, physical),
  flowBind(Flowname, Protocol, Port),
  isCredential(Flowname, DstZone, Account),
  vulLinkProtocol(WirelessRange, VulID, Protocol, adjacent, keyReinstallation),
  isAP(AP, WirelessRange, DstZone, Protocol, secured),
  located(Host, WirelessRange, physical)),
 rule_desc('WPA2 Key Reinstallation. (1) The attacker becomes a MITM between the host and the access point (e.g., by channel-based MITM technique); and (2) the attacker prevents the 4th handshake message from reaching the access point, which causes the retransmission of the 3rd message.', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (crackPINCode(User, SrcHost, DstHost, BluetoothProt):-
  malicious(User),
  accessDataFlow(User, Flowname, read),
  isPairingProcess(Flowname),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port)),
 rule_desc('Bluetooth PIN Cracking; Principal got the PIN code of the Bluetooth communication. The attacker Principal (represented by the malicious predicate) can read the messages exchanged by two devices (represented by the accessDataFlow, dataFlow, and flowBind) during their pairing process (represented by the isPairingProcess).', 1.0)).

interaction_rule(
 (crackPINCode(User, DstHost, SrcHost, BluetoothProt):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt)),
 rule_desc('Principal got the PIN code of the Bluetooth communication', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (crackPINCode(User, SrcHost, DstHost, BluetoothProt):-
  malicious(User),
  accessDataFlow(User, Flowname, read),
  isPairingProcess(Flowname),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port)),
 rule_desc('Bluetooth PIN Cracking; Principal got the PIN code of the Bluetooth communication. The attacker Principal (represented by the malicious predicate) can read the messages exchanged by two devices (represented by the accessDataFlow, dataFlow, and flowBind) during their pairing process (represented by the isPairingProcess).', 1.0)).

interaction_rule(
 (crackPINCode(User, DstHost, SrcHost, BluetoothProt):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt)),
 rule_desc('Principal got the PIN code of the Bluetooth communication', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (crackPINCode(User, SrcHost, DstHost, BluetoothProt):-
  malicious(User),
  accessDataFlow(User, Flowname, read),
  isPairingProcess(Flowname),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port)),
 rule_desc('Bluetooth PIN Cracking; Principal got the PIN code of the Bluetooth communication. The attacker Principal (represented by the malicious predicate) can read the messages exchanged by two devices (represented by the accessDataFlow, dataFlow, and flowBind) during their pairing process (represented by the isPairingProcess).', 1.0)).

interaction_rule(
 (crackPINCode(User, DstHost, SrcHost, BluetoothProt):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt)),
 rule_desc('Principal got the PIN code of the Bluetooth communication', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (crackPINCode(User, SrcHost, DstHost, BluetoothProt):-
  malicious(User),
  accessDataFlow(User, Flowname, read),
  isPairingProcess(Flowname),
  dataFlow(SrcHost, DstHost, Flowname, Direction),
  flowBind(Flowname, BluetoothProt, _Port)),
 rule_desc('Bluetooth PIN Cracking; Principal got the PIN code of the Bluetooth communication. The attacker Principal (represented by the malicious predicate) can read the messages exchanged by two devices (represented by the accessDataFlow, dataFlow, and flowBind) during their pairing process (represented by the isPairingProcess).', 1.0)).

interaction_rule(
 (crackPINCode(User, DstHost, SrcHost, BluetoothProt):-
  crackPINCode(User, SrcHost, DstHost, BluetoothProt)),
 rule_desc('Principal got the PIN code of the Bluetooth communication', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol(Subnet, VulID, Protocol, Range, Consequence),
  located(HostA, Subnet, SubnetType),
  located(HostB, Subnet, SubnetType)),
 rule_desc('Communication between hosts in the same subnet via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostA, HostB, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (vulLinkProtocol(HostA, HostB, VulID, Protocol, Range, Consequence):-
  vulLinkProtocol_p(HostB, HostA, VulID, Protocol, Range, Consequence, twoWay)),
 rule_desc('Communication between hosts via vulnerable link layer protocol', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (localAccess(attacker ,Host, admin):-
  attackerLocated(Host)),
 rule_desc('', 1.0)).

interaction_rule(
 (localAccess(User, Host, Account):-
  execCode(User, Host, Account)),
 rule_desc('Principal can execute any code', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, Account):-
  hasAccount(User, DstHost, Account),
  networkService(DstHost, Software, Prot, Port, LoginServiceAccount),
  netAccess(User, SrcHost, DstHost, Prot, Port),
  aclH(DstHost, LoginServiceAccount, SrcHost, Prot, Port),
  isLoginService(Software)),
 rule_desc('Principal has account and can access via network', 1.0)).

interaction_rule(
 (localAccess(User, DstHost, NetServiceAccount):-
  netAccess(User, SrcHost, DstHost, Protocol, Port),
  networkService(DstHost, Software, Prot, Port, NetServiceAccount),
  vulHost(DstHost, _vulID, Software, remoteExploit, execCode),
  malicious(User)),
 rule_desc('Principal can login to DstHost as NetworkServiceUser.', 1.0)).

interaction_rule(
 (localAccess(User, Host, admin):-
  localService(Host, Software, Account),
  vulHost(Host, _vulID, Software, localExploit, privEsc),
  malicious(User),
  localAccess(User, Host, Account)),
 rule_desc('', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcSubnet, DstSubnet, Prot, Port)),
 rule_desc('Connectivity inter subnets', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(DstHost, DstSubnet, SubnetType),
  aclNW(SrcHost, DstSubnet, Prot, Port)),
 rule_desc('Connectivity from host to subnet', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, Prot, Port):-
  located(SrcHost, SrcSubnet, SubnetType),
  aclNW(SrcSubnet, DstHost, Prot, Port)),
 rule_desc('Connectivity from subnet to host', 1.0)).

interaction_rule(
 (aclNW(SrcHost, DstHost, _prot, _port):-
  located(SrcHost, Subnet, SubnetType),
  located(DstHost, Subnet, SubnetType)),
 rule_desc('connectivity within a subnet', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (vulHost(Host, ID, Software, Range, Consequense):-
  vulHost(Host, ID, DependedSoftware, Range, Consequense),
  dependsOn(Host, Software, DependedSoftware)),
 rule_desc('A software depends on vulLibrary', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BusID, Prot, bus):-
  located(SrcHost, BusID, bus),
  located(DstHost, BusID, bus),
  existingProtocol(BusID, Prot)),
 rule_desc('Connectivity within a bus', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, AP, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, SrcHost, AP),
  located(SrcHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an authenticated host and an encrypted AP', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, Bluetooth, wireless):-
  inDiscoveryMode(DstHost),
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, Bluetooth)),
 rule_desc('Communication between devices on bluetoothRange', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, BluetoothRange, BluetoothProt, wireless):-
  located(SrcHost, BluetoothRange, physical),
  located(DstHost, BluetoothRange, physical),
  existingProtocol(BluetoothRange, BluetoothProt),
  vulLinkProtocol(BluetoothRange, VulID, BluetoothProt, BluetoothRange, establishConnection),
  malicious(User),
  localAccess(User, SrcHost, Account)),
 rule_desc('Communication between devices using vulnerability', 1.0)).

interaction_rule(
 (l2Connection(SrcHost, DstHost, Subnet, Prot, ipSubnet):-
  located(SrcHost, Subnet, ipSubnet),
  located(DstHost, Subnet, ipSubnet),
  existingProtocol(Subnet, Prot)),
 rule_desc('Connectivity within a subnet', 1.0)).

interaction_rule(
 (l2Connection(AP, DstHost, WirelessRange, Prot, wireless):-
  isAP(AP, WirelessRange, DstZone, Prot, secured),
  isAuthenticated(_User, DstHost, AP),
  located(DstHost, WirelessRange, physical)),
 rule_desc('Wireless connection between an encrypted AP and authenticated host', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (located(SrcHost, DstZone, Type):-
  l2Connection(SrcHost, AP, WirelessRange, WirelessProt, wireless),
  isAP(AP, WirelessRange, DstZone, WirelessProt, SecurityConf),
  located(AP, DstZone, Type)),
 rule_desc('Located via AP', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (accessMaliciousInput(Host, Victim, Software) :-
  inCompetent(Victim),
  isClient(Software),
  hacl(Host, MaliciousMachine, httpProtocol, httpPort),
  attackerLocated(MaliciousMachine)),
 rule_desc('', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (firstHop(Host1, Host2) :-
  hacl(Host1, Host2, _Protocol, _Port),
  hacl(Host2, Host1, _Protocol, _Port)),
 rule_desc('First hop of network traffic', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (sameSwitch(Host1, Host2) :-
  notSame(Host1,Host2),
  notSame(Host1, Intermediary),
  notSame(Host2, Intermediary),
  networkHardware(Intermediary),
  notNetDev(Host1),
  notNetDev(Host2),
  hacl(Host1, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host1, _Protocol, _Port),
  hacl(Host2, Intermediary, _Protocol, _Port),
  hacl(Intermedieary, Host2, _Protocol, _Port)),
 rule_desc('On same network switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(Intermediary, Intermediary2),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, TgtHost, _Protocol, _Port))),
 rule_desc('Multi-hop between switches', 1.0)).

interaction_rule(
 (multiHop(SrcHost, TgtHost) :-
  notSame(SrcHost, TgtHost),
  notSame(SrcHost, Intermediary),
  notSame(SrcHost, Intermediary2),
  notSame(SrcHost, Intermediary3),
  notSame(TgtHost, Intermediary),
  notSame(TgtHost, Intermediary2),
  notSame(TgtHost, Intermediary3),
  notSame(Intermediary, Intermediary2),
  notSame(Intermediary2, Intermediary3),
  notSame(Intermediary, Intermediary3),
  notNetDev(SrcHost),
  notNetDev(TgtHost),
  networkHardware(Intermediary),
  networkHardware(Intermediary2),
  networkHardware(Intermediary3),
  hacl(SrcHost, Intermediary, _Protocol, _Port),
  hacl(Intermediary, SrcHost, _Protocol, _Port),
  hacl(Intermediary, Intermediary2, _Protocol, _Port),
  hacl(Intermediary2, Intermediary, _Protocol, _Port),
  hacl(Intermediary2, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, Intermediary2, _Protocol, _Port),
  hacl(TgtHost, Intermediary3, _Protocol, _Port),
  hacl(Intermediary3, TgtHost, _Protocol, _Port)),
 rule_desc('', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (stealthyBridgeExists(Vm_1, Vm_2, Host, stealthyBridge_id) :-
  execCode(_User, Vm_1, _Account),
  resideOn(Vm_1, Host),
  resideOn(Vm_2, Host)),
 rule_desc('A stealthy bridge could be built between virtual machines co-residing on the same host after one virtual machine is compromised.', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (leakInfo(Host, code) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readcode)),
 rule_desc('Leaking code information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, file) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readfile)),
 rule_desc('Leaking file information due to a vulnerability', 1.0)).

interaction_rule(
 (leakInfo(Host, data) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, readdata)),
 rule_desc('Leaking data information due to a vulnerability', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, writecode)),
 rule_desc('Tampering the code memory', 1.0)).

interaction_rule(
 (execArbitraryCode(Host, _Account) :-
  execCode(_User, Host, _Account),
  vulExists(Host, _VulID, Software, _ExploitRange, execArbitCode)),
 rule_desc('Executing an arbitrary code', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  firstHop(SrcHost, TgtHost)),
 rule_desc('Direct access to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost) :-
  execCode(_User, SrcHost, _Account),
  sameSwitch(SrcHost, TgtHost)),
 rule_desc('Same switch from pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, TgtHost)),
 rule_desc('Multiple switches to pivot point', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  sameSwitch(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- same switch', 1.0)).

interaction_rule(
 (pivotPoint(SrcHost, TgtHost):-
  execCode(_User, SrcHost, _Account),
  multiHop(SrcHost, Intermediary),
  execCode(SrcHost, Intermediary, _Account),
  multiHop(Intermediary, TgtHost)),
 rule_desc('Dual pivot -- multiple switches', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (dataTransitsThrough(Host, FileName) :-
  firstHop(TXhost, Host),
  firstHop(RXhost, Host),
  sendsFile(TXhost, RXhost, FileName, TxSoftware),
  listenForFiles(RXhost, RxSoftware)),
 rule_desc('Files are going through entity before reaching destination', 1.0)).

interaction_rule(
 (principalCompromised (_User) :-
  principalCompromised (Attacker),
  canAccess (Attacker, service_change_config, Service)),
 rule_desc('If you have been compromised by the attacker, and your account can change the service configuration of a Service to run the attacker's .EXE file in a process owned by Principal, then you can compromise that Principal.', 1.0)).

interaction_rule(
 (principalCompromised (User) :-
  principalCompromised (Attacker),
  canAccess (Attacker, write, File),
  canAccess (User, execute, File)),
 rule_desc('If you can write to a file that some Principal can execute, then you can install a Trojan Horse that makes that Principal act on your behalf.', 1.0)).

interaction_rule(
 (principalCompromised (_User) :-
  principalCompromised (Attacker),
  canAccess (Attacker, service_change_config, Service)),
 rule_desc('If you have been compromised by the attacker, and your account can change the service configuration of a Service to run the attacker's .EXE file in a process owned by Principal, then you can compromise that Principal.', 1.0)).

interaction_rule(
 (principalCompromised (User) :-
  principalCompromised (Attacker),
  canAccess (Attacker, write, File),
  canAccess (User, execute, File)),
 rule_desc('If you can write to a file that some Principal can execute, then you can install a Trojan Horse that makes that Principal act on your behalf.', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
 malicious(User),
 model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
 publicModel(ModelID)),
 rule_desc('Hyper parameters knowledge using public model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Algorithm knowledge using public model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, read, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
 malicious(User),
 model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
 publicModel(ModelID)),
 rule_desc('Hyper parameters knowledge using public model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Algorithm knowledge using public model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, read, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
 malicious(User),
 model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
 publicModel(ModelID)),
 rule_desc('Hyper parameters knowledge using public model', 1.0)).

interaction_rule(
 (hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Algorithm knowledge using public model', 1.0)).

interaction_rule(
 (algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, read, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  publicModel(ModelID)),
 rule_desc('Model knowledge using public model', 1.0)).

interaction_rule(
 (modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  modelAccess(User, PiplineID, ModelID, _AccessType, _AccessLevel)),
 rule_desc('Has access to model', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, read, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, read, TrainingDataID)),
 rule_desc('has read access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, write, TrainingDataID)),
 rule_desc('has write access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, append, AccessLevel) :-
  malicious(User),
  mode(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, TrainDataHost, append, TrainingDataID)),
 rule_desc('has append access to training data', 1.0)).

interaction_rule(
 (trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  manipulateTrainingData(User, PiplineID, ModelID)),
 rule_desc('can change training data by manipulation of features data', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Program, Prot, Port, PredictionsGranularity),
  netAccess(User, _SrcHost, PredictionServiceHost, Prot, Port)),
 rule_desc('Query access via prediction service', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, AccessLevel) :-
  malicious(User),
  predictionService(PiplineID, ModelID, ServingApiID, PredictionServiceHost, Software, Prot, Port, PredictionsGranularity),
  predictorClientApplication(ClientApiID, ServingApiID, PredictorClientApplicationHost, Software),
  netAccess(User, _SrcHost, PredictorClientApplicationHost, Prot, Port)),
 rule_desc('Query access via prediction client application', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, decision, AccessLevel) :-
  queryAccess(User, PiplineID, ModelID, score, AccessLevel)),
 rule_desc('Query access via query access with score prediction granularity', 1.0)).

interaction_rule(
 (queryAccess(User, PiplineID, ModelID, PredictionsGranularity, limited) :-
  queryAccess(User, PiplineID, ModelID, PredictionsGranularity, full)),
 rule_desc('Limited query access via full query access', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  dataIsPublic(TrainingDataID)),
 rule_desc('Know training data using public data', 1.0)).

interaction_rule(
 (trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel) :-
  trainingDataAccess(User, PiplineID, ModelID, TrainingDataID, DataAccessPrivilege, AccessLevel)),
 rule_desc('Has access to training data', 1.0)).

interaction_rule(
 (modelAccess(User, PiplineID, ModelID, write, AccessLevel) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, ModelHost, write, ModelID)),
 rule_desc('has write access to model', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  trainingData(DataID, TrainingDataHost),
  accessFile(User, TrainingDataHost, write, TrainingDataID)),
 rule_desc('Manipulate training data through direct access to the training set', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  trainingData(TrainingDataID, TrainingDataHost),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID, JobHost, InputDataID, InputDataHost, TrainingDataID, TrainingDataHost)),
 rule_desc('Manipulate training data through access to feature store', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID1, JobHost1, InputDataID, InputDataHost, TransformedDataID, TransformedDataHost),
  dataTransformationJob(JobID2, JobHost2, TransformedDataID, TransformedDataHost, TrainingDataID, TrainDataHost)),
 rule_desc('Manipulate training data through access to raw data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  trainingData(DataID, TrainingDataHost),
  accessFile(User, TrainingDataHost, write, TrainingDataID)),
 rule_desc('Manipulate training data through direct access to the training set', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  trainingData(TrainingDataID, TrainingDataHost),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID, JobHost, InputDataID, InputDataHost, TrainingDataID, TrainingDataHost)),
 rule_desc('Manipulate training data through access to feature store', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID1, JobHost1, InputDataID, InputDataHost, TransformedDataID, TransformedDataHost),
  dataTransformationJob(JobID2, JobHost2, TransformedDataID, TransformedDataHost, TrainingDataID, TrainDataHost)),
 rule_desc('Manipulate training data through access to raw data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  trainingData(DataID, TrainingDataHost),
  accessFile(User, TrainingDataHost, write, TrainingDataID)),
 rule_desc('Manipulate training data through direct access to the training set', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  trainingData(TrainingDataID, TrainingDataHost),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID, JobHost, InputDataID, InputDataHost, TrainingDataID, TrainingDataHost)),
 rule_desc('Manipulate training data through access to feature store', 1.0)).

interaction_rule(
 (manipulateTrainingData(User, PiplineID, ModelID) :-
  malicious(User),
  model(PiplineID, AlgorithmID, ModelID, ModelHost, TrainingDataID, LabelsDataID, ValidationDataID),
  accessFile(User, InputDataHost, write, InputDataID),
  dataTransformationJob(JobID1, JobHost1, InputDataID, InputDataHost, TransformedDataID, TransformedDataHost),
  dataTransformationJob(JobID2, JobHost2, TransformedDataID, TransformedDataHost, TrainingDataID, TrainDataHost)),
 rule_desc('Manipulate training data through access to raw data', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  modelKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  hyperparametersKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  algorithmKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  trainingDataKnowledge(User, PiplineID, ModelID, TrainingDataID, KnowledgeLevel),
  rawDataKnowledge(User, PiplineID, ModelID, RawDataID, KnowledgeLevel),
  dataPropertiesKnowledge(User, PiplineID, ModelID, KnowledgeLevel),
  taskKnowledge(User, PiplineID, ModelID, KnowledgeLevel)),
 rule_desc('Has complete knowledge of the target pipeline', 1.0)).

interaction_rule(
 (completeKnowledge(User, PiplineID, ModelID) :-
  malicious(User),
  completeAccess(User, PiplineID, ModelID, _DataAccessPrivilege)),
 rule_desc('Has complete access', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

interaction_rule(
 (dataTransformationJob(JobID, WorkerHost, InputDataID, WorkerHost, TransformedDataID, TransformedDataHost) :-
  dataTransformationJob(JobID, ClusterGatewayHost, InputDataID, ClusterGatewayHost, TransformedDataID, TransformedDataHost),
  clusterWorker(WorkerHost, ClusterGatewayHost, ClusterMasterHost)),
 rule_desc('Manipulate training data through job submission propogation from cluster gateway to workers', 1.0)).

